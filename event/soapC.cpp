/* soapC.cpp
   Generated by gSOAP 2.8.60 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.60 2019-11-11 16:13:25 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, NULL, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		return soap_in_wstop__SimpleTopicExpression(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return soap_in_wstop__ConcreteTopicExpression(soap, NULL, NULL, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_wstop__FullTopicExpression:
		return soap_in_wstop__FullTopicExpression(soap, NULL, NULL, "wstop:FullTopicExpression");
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		return soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, NULL, NULL, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_wstop__TopicSetType:
		return soap_in_wstop__TopicSetType(soap, NULL, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_wstop__TopicType:
		return soap_in_wstop__TopicType(soap, NULL, NULL, "wstop:TopicType");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return soap_in_wstop__TopicNamespaceType(soap, NULL, NULL, "wstop:TopicNamespaceType");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return soap_in_wstop__QueryExpressionType(soap, NULL, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return soap_in_wstop__ExtensibleDocumented(soap, NULL, NULL, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return soap_in_wstop__Documentation(soap, NULL, NULL, "wstop:Documentation");
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return soap_in_wsnt__ResumeFailedFaultType(soap, NULL, NULL, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return soap_in_wsnt__PauseFailedFaultType(soap, NULL, NULL, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, NULL, NULL, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, NULL, NULL, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return soap_in_wsnt__UnableToGetMessagesFaultType(soap, NULL, NULL, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return soap_in_wsnt__TopicNotSupportedFaultType(soap, NULL, NULL, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, NULL, NULL, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return soap_in_wsnt__InvalidFilterFaultType(soap, NULL, NULL, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, NULL, NULL, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return soap_in_wsnt__NotificationMessageHolderType(soap, NULL, NULL, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return soap_in_wsnt__SubscriptionPolicyType(soap, NULL, NULL, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_wsnt__FilterType:
		return soap_in_wsnt__FilterType(soap, NULL, NULL, "wsnt:FilterType");
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return soap_in_wsnt__TopicExpressionType(soap, NULL, NULL, "wsnt:TopicExpressionType");
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return soap_in_wsnt__QueryExpressionType(soap, NULL, NULL, "wsnt:QueryExpressionType");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return soap_in_wsrfbf__BaseFaultType(soap, NULL, NULL, "wsrfbf:BaseFaultType");
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		return soap_in_wsrfr__ResourceUnavailableFaultType(soap, NULL, NULL, "wsrfr:ResourceUnavailableFaultType");
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		return soap_in_wsrfr__ResourceUnknownFaultType(soap, NULL, NULL, "wsrfr:ResourceUnknownFaultType");
	case SOAP_TYPE_tev__Capabilities:
		return soap_in_tev__Capabilities(soap, NULL, NULL, "tev:Capabilities");
	case SOAP_TYPE_xsd__token:
		return soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, NULL, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, NULL, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscription:
		return soap_in_PointerTo_wsnt__ResumeSubscription(soap, NULL, NULL, "wsnt:ResumeSubscription");
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscription:
		return soap_in_PointerTo_wsnt__PauseSubscription(soap, NULL, NULL, "wsnt:PauseSubscription");
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPoint:
		return soap_in_PointerTo_wsnt__CreatePullPoint(soap, NULL, NULL, "wsnt:CreatePullPoint");
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint:
		return soap_in_PointerTo_wsnt__DestroyPullPoint(soap, NULL, NULL, "wsnt:DestroyPullPoint");
	case SOAP_TYPE_PointerTo_wsnt__GetMessages:
		return soap_in_PointerTo_wsnt__GetMessages(soap, NULL, NULL, "wsnt:GetMessages");
	case SOAP_TYPE_PointerTo_wsnt__Notify:
		return soap_in_PointerTo_wsnt__Notify(soap, NULL, NULL, "wsnt:Notify");
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage:
		return soap_in_PointerTo_wsnt__GetCurrentMessage(soap, NULL, NULL, "wsnt:GetCurrentMessage");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe:
		return soap_in_PointerTo_wsnt__Subscribe(soap, NULL, NULL, "wsnt:Subscribe");
	case SOAP_TYPE_PointerTo_wsnt__Renew:
		return soap_in_PointerTo_wsnt__Renew(soap, NULL, NULL, "wsnt:Renew");
	case SOAP_TYPE_PointerTo_tev__GetEventProperties:
		return soap_in_PointerTo_tev__GetEventProperties(soap, NULL, NULL, "tev:GetEventProperties");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription:
		return soap_in_PointerTo_tev__CreatePullPointSubscription(soap, NULL, NULL, "tev:CreatePullPointSubscription");
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilities:
		return soap_in_PointerTo_tev__GetServiceCapabilities(soap, NULL, NULL, "tev:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_wsnt__Unsubscribe:
		return soap_in_PointerTo_wsnt__Unsubscribe(soap, NULL, NULL, "wsnt:Unsubscribe");
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint:
		return soap_in_PointerTo_tev__SetSynchronizationPoint(soap, NULL, NULL, "tev:SetSynchronizationPoint");
	case SOAP_TYPE_PointerTo_tev__Seek:
		return soap_in_PointerTo_tev__Seek(soap, NULL, NULL, "tev:Seek");
	case SOAP_TYPE_PointerTo_tev__PullMessages:
		return soap_in_PointerTo_tev__PullMessages(soap, NULL, NULL, "tev:PullMessages");
	case SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType:
		return soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType:
		return soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType:
		return soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType:
		return soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, NULL, NULL, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType:
		return soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType:
		return soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, NULL, NULL, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType:
		return soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, NULL, NULL, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType:
		return soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, NULL, NULL, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType:
		return soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType:
		return soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, NULL, NULL, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType:
		return soap_in_PointerTowsnt__ResumeFailedFaultType(soap, NULL, NULL, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType:
		return soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, NULL, NULL, "wsrfr:ResourceUnknownFaultType");
	case SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse:
		return soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, NULL, NULL, "tev:PullMessagesFaultResponse");
	case SOAP_TYPE_PointerTowsnt__PauseFailedFaultType:
		return soap_in_PointerTowsnt__PauseFailedFaultType(soap, NULL, NULL, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType:
		return soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType:
		return soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType:
		return soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType:
		return soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, NULL, NULL, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType:
		return soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType:
		return soap_in_PointerTowsnt__InvalidFilterFaultType(soap, NULL, NULL, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_in_PointerToxsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		return soap_in_PointerTowstop__ConcreteTopicExpression(soap, NULL, NULL, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_in_PointerToxsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_in_PointerTowstop__TopicType(soap, NULL, NULL, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_in_PointerTowstop__QueryExpressionType(soap, NULL, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_in_PointerTowstop__Documentation(soap, NULL, NULL, "wstop:Documentation");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		return soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, NULL, NULL, "wsnt:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		return soap_in_PointerTowsnt__SubscriptionPolicyType(soap, NULL, NULL, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		return soap_in_PointerTowsnt__TopicExpressionType(soap, NULL, NULL, "wsnt:TopicExpressionType");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, NULL, NULL, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_in_PointerTo_xml__lang(soap, NULL, NULL, "xml:lang");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, NULL, NULL, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_in_PointerTowsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_in_PointerTowstop__TopicSetType(soap, NULL, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		return soap_in_PointerTowsnt__NotificationMessageHolderType(soap, NULL, NULL, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy:
		return soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, NULL, NULL, "tev:CreatePullPointSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType:
		return soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, NULL, NULL, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTowsnt__FilterType:
		return soap_in_PointerTowsnt__FilterType(soap, NULL, NULL, "wsnt:FilterType");
	case SOAP_TYPE_PointerTotev__Capabilities:
		return soap_in_PointerTotev__Capabilities(soap, NULL, NULL, "tev:Capabilities");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, NULL, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, NULL, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, NULL, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, NULL, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, NULL, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_wstop__SimpleTopicExpression;
			return soap_in_wstop__SimpleTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:ConcreteTopicExpression"))
		{	*type = SOAP_TYPE_wstop__ConcreteTopicExpression;
			return soap_in_wstop__ConcreteTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:FullTopicExpression"))
		{	*type = SOAP_TYPE_wstop__FullTopicExpression;
			return soap_in_wstop__FullTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:AbsoluteOrRelativeTimeType"))
		{	*type = SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType;
			return soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicSetType"))
		{	*type = SOAP_TYPE_wstop__TopicSetType;
			return soap_in_wstop__TopicSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicType"))
		{	*type = SOAP_TYPE_wstop__TopicType;
			return soap_in_wstop__TopicType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType"))
		{	*type = SOAP_TYPE_wstop__TopicNamespaceType;
			return soap_in_wstop__TopicNamespaceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:QueryExpressionType"))
		{	*type = SOAP_TYPE_wstop__QueryExpressionType;
			return soap_in_wstop__QueryExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:ExtensibleDocumented"))
		{	*type = SOAP_TYPE_wstop__ExtensibleDocumented;
			return soap_in_wstop__ExtensibleDocumented(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:Documentation"))
		{	*type = SOAP_TYPE_wstop__Documentation;
			return soap_in_wstop__Documentation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__ResumeFailedFaultType;
			return soap_in_wsnt__ResumeFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__PauseFailedFaultType;
			return soap_in_wsnt__PauseFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType;
			return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType;
			return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType;
			return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType;
			return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToGetMessagesFaultType;
			return soap_in_wsnt__UnableToGetMessagesFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType"))
		{	*type = SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType;
			return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType;
			return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType;
			return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType;
			return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType;
			return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType;
			return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType;
			return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType"))
		{	*type = SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType;
			return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnt__TopicNotSupportedFaultType;
			return soap_in_wsnt__TopicNotSupportedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType;
			return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType"))
		{	*type = SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType;
			return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidFilterFaultType;
			return soap_in_wsnt__InvalidFilterFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType;
			return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessageHolderType"))
		{	*type = SOAP_TYPE_wsnt__NotificationMessageHolderType;
			return soap_in_wsnt__NotificationMessageHolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionPolicyType"))
		{	*type = SOAP_TYPE_wsnt__SubscriptionPolicyType;
			return soap_in_wsnt__SubscriptionPolicyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:FilterType"))
		{	*type = SOAP_TYPE_wsnt__FilterType;
			return soap_in_wsnt__FilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionType"))
		{	*type = SOAP_TYPE_wsnt__TopicExpressionType;
			return soap_in_wsnt__TopicExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:QueryExpressionType"))
		{	*type = SOAP_TYPE_wsnt__QueryExpressionType;
			return soap_in_wsnt__QueryExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType"))
		{	*type = SOAP_TYPE_wsrfbf__BaseFaultType;
			return soap_in_wsrfbf__BaseFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnavailableFaultType"))
		{	*type = SOAP_TYPE_wsrfr__ResourceUnavailableFaultType;
			return soap_in_wsrfr__ResourceUnavailableFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnknownFaultType"))
		{	*type = SOAP_TYPE_wsrfr__ResourceUnknownFaultType;
			return soap_in_wsrfr__ResourceUnknownFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:Capabilities"))
		{	*type = SOAP_TYPE_tev__Capabilities;
			return soap_in_tev__Capabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token;
			return soap_in_xsd__token(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName;
			return soap_in_xsd__NCName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TerminationTime"))
		{	*type = SOAP_TYPE__wsnt__TerminationTime;
			return soap_in__wsnt__TerminationTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CurrentTime"))
		{	*type = SOAP_TYPE__wsnt__CurrentTime;
			return soap_in__wsnt__CurrentTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreationTime"))
		{	*type = SOAP_TYPE__wsnt__CreationTime;
			return soap_in__wsnt__CreationTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:topic"))
		{	*type = SOAP_TYPE__wstop__topic;
			return soap_in__wstop__topic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:FixedTopicSet"))
		{	*type = SOAP_TYPE__wsnt__FixedTopicSet;
			return soap_in__wsnt__FixedTopicSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:topicNamespaceLocation"))
		{	*type = SOAP_TYPE__wstop__topicNamespaceLocation;
			return soap_in__wstop__topicNamespaceLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicSet"))
		{	*type = SOAP_TYPE__wstop__TopicSet;
			return soap_in__wstop__TopicSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespace"))
		{	*type = SOAP_TYPE__wstop__TopicNamespace;
			return soap_in__wstop__TopicNamespace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFault"))
		{	*type = SOAP_TYPE__wsnt__ResumeFailedFault;
			return soap_in__wsnt__ResumeFailedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFault"))
		{	*type = SOAP_TYPE__wsnt__PauseFailedFault;
			return soap_in__wsnt__PauseFailedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFault"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroySubscriptionFault;
			return soap_in__wsnt__UnableToDestroySubscriptionFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFault"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableTerminationTimeFault;
			return soap_in__wsnt__UnacceptableTerminationTimeFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFault"))
		{	*type = SOAP_TYPE__wsnt__UnableToCreatePullPointFault;
			return soap_in__wsnt__UnableToCreatePullPointFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFault"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroyPullPointFault;
			return soap_in__wsnt__UnableToDestroyPullPointFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFault"))
		{	*type = SOAP_TYPE__wsnt__UnableToGetMessagesFault;
			return soap_in__wsnt__UnableToGetMessagesFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFault"))
		{	*type = SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFault;
			return soap_in__wsnt__NoCurrentMessageOnTopicFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFault"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFault;
			return soap_in__wsnt__UnacceptableInitialTerminationTimeFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFault"))
		{	*type = SOAP_TYPE__wsnt__NotifyMessageNotSupportedFault;
			return soap_in__wsnt__NotifyMessageNotSupportedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFault"))
		{	*type = SOAP_TYPE__wsnt__UnsupportedPolicyRequestFault;
			return soap_in__wsnt__UnsupportedPolicyRequestFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFault"))
		{	*type = SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFault;
			return soap_in__wsnt__UnrecognizedPolicyRequestFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFault"))
		{	*type = SOAP_TYPE__wsnt__InvalidMessageContentExpressionFault;
			return soap_in__wsnt__InvalidMessageContentExpressionFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFault"))
		{	*type = SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFault;
			return soap_in__wsnt__InvalidProducerPropertiesExpressionFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFault"))
		{	*type = SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFault;
			return soap_in__wsnt__MultipleTopicsSpecifiedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFault"))
		{	*type = SOAP_TYPE__wsnt__TopicNotSupportedFault;
			return soap_in__wsnt__TopicNotSupportedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFault"))
		{	*type = SOAP_TYPE__wsnt__InvalidTopicExpressionFault;
			return soap_in__wsnt__InvalidTopicExpressionFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFault"))
		{	*type = SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFault;
			return soap_in__wsnt__TopicExpressionDialectUnknownFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFault"))
		{	*type = SOAP_TYPE__wsnt__InvalidFilterFault;
			return soap_in__wsnt__InvalidFilterFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFault"))
		{	*type = SOAP_TYPE__wsnt__SubscribeCreationFailedFault;
			return soap_in__wsnt__SubscribeCreationFailedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MessageContent"))
		{	*type = SOAP_TYPE__wsnt__MessageContent;
			return soap_in__wsnt__MessageContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ProducerProperties"))
		{	*type = SOAP_TYPE__wsnt__ProducerProperties;
			return soap_in__wsnt__ProducerProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessage"))
		{	*type = SOAP_TYPE__wsnt__NotificationMessage;
			return soap_in__wsnt__NotificationMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Topic"))
		{	*type = SOAP_TYPE__wsnt__Topic;
			return soap_in__wsnt__Topic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionPolicy"))
		{	*type = SOAP_TYPE__wsnt__SubscriptionPolicy;
			return soap_in__wsnt__SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Filter"))
		{	*type = SOAP_TYPE__wsnt__Filter;
			return soap_in__wsnt__Filter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialect"))
		{	*type = SOAP_TYPE__wsnt__TopicExpressionDialect;
			return soap_in__wsnt__TopicExpressionDialect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpression"))
		{	*type = SOAP_TYPE__wsnt__TopicExpression;
			return soap_in__wsnt__TopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFault"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFault;
			return soap_in__wsrfbf__BaseFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnavailableFault"))
		{	*type = SOAP_TYPE__wsrfr__ResourceUnavailableFault;
			return soap_in__wsrfr__ResourceUnavailableFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnknownFault"))
		{	*type = SOAP_TYPE__wsrfr__ResourceUnknownFault;
			return soap_in__wsrfr__ResourceUnknownFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:Capabilities"))
		{	*type = SOAP_TYPE__tev__Capabilities;
			return soap_in__tev__Capabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType-Topic"))
		{	*type = SOAP_TYPE__wstop__TopicNamespaceType_Topic;
			return soap_in__wstop__TopicNamespaceType_Topic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Subscribe-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy;
			return soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessageHolderType-Message"))
		{	*type = SOAP_TYPE__wsnt__NotificationMessageHolderType_Message;
			return soap_in__wsnt__NotificationMessageHolderType_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause;
			return soap_in__wsrfbf__BaseFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-Description"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_Description;
			return soap_in__wsrfbf__BaseFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode;
			return soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:CreatePullPointSubscription-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy;
			return soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnt__ResumeSubscriptionResponse;
			return soap_in__wsnt__ResumeSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeSubscription"))
		{	*type = SOAP_TYPE__wsnt__ResumeSubscription;
			return soap_in__wsnt__ResumeSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnt__PauseSubscriptionResponse;
			return soap_in__wsnt__PauseSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseSubscription"))
		{	*type = SOAP_TYPE__wsnt__PauseSubscription;
			return soap_in__wsnt__PauseSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsubscribeResponse"))
		{	*type = SOAP_TYPE__wsnt__UnsubscribeResponse;
			return soap_in__wsnt__UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Unsubscribe"))
		{	*type = SOAP_TYPE__wsnt__Unsubscribe;
			return soap_in__wsnt__Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:RenewResponse"))
		{	*type = SOAP_TYPE__wsnt__RenewResponse;
			return soap_in__wsnt__RenewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Renew"))
		{	*type = SOAP_TYPE__wsnt__Renew;
			return soap_in__wsnt__Renew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreatePullPointResponse"))
		{	*type = SOAP_TYPE__wsnt__CreatePullPointResponse;
			return soap_in__wsnt__CreatePullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreatePullPoint"))
		{	*type = SOAP_TYPE__wsnt__CreatePullPoint;
			return soap_in__wsnt__CreatePullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:DestroyPullPointResponse"))
		{	*type = SOAP_TYPE__wsnt__DestroyPullPointResponse;
			return soap_in__wsnt__DestroyPullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:DestroyPullPoint"))
		{	*type = SOAP_TYPE__wsnt__DestroyPullPoint;
			return soap_in__wsnt__DestroyPullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetMessagesResponse"))
		{	*type = SOAP_TYPE__wsnt__GetMessagesResponse;
			return soap_in__wsnt__GetMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetMessages"))
		{	*type = SOAP_TYPE__wsnt__GetMessages;
			return soap_in__wsnt__GetMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetCurrentMessageResponse"))
		{	*type = SOAP_TYPE__wsnt__GetCurrentMessageResponse;
			return soap_in__wsnt__GetCurrentMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetCurrentMessage"))
		{	*type = SOAP_TYPE__wsnt__GetCurrentMessage;
			return soap_in__wsnt__GetCurrentMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeResponse"))
		{	*type = SOAP_TYPE__wsnt__SubscribeResponse;
			return soap_in__wsnt__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Subscribe"))
		{	*type = SOAP_TYPE__wsnt__Subscribe;
			return soap_in__wsnt__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UseRaw"))
		{	*type = SOAP_TYPE__wsnt__UseRaw;
			return soap_in__wsnt__UseRaw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Notify"))
		{	*type = SOAP_TYPE__wsnt__Notify;
			return soap_in__wsnt__Notify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionManagerRP"))
		{	*type = SOAP_TYPE__wsnt__SubscriptionManagerRP;
			return soap_in__wsnt__SubscriptionManagerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationProducerRP"))
		{	*type = SOAP_TYPE__wsnt__NotificationProducerRP;
			return soap_in__wsnt__NotificationProducerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetEventPropertiesResponse"))
		{	*type = SOAP_TYPE__tev__GetEventPropertiesResponse;
			return soap_in__tev__GetEventPropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetEventProperties"))
		{	*type = SOAP_TYPE__tev__GetEventProperties;
			return soap_in__tev__GetEventProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:SetSynchronizationPointResponse"))
		{	*type = SOAP_TYPE__tev__SetSynchronizationPointResponse;
			return soap_in__tev__SetSynchronizationPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:SetSynchronizationPoint"))
		{	*type = SOAP_TYPE__tev__SetSynchronizationPoint;
			return soap_in__tev__SetSynchronizationPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:SeekResponse"))
		{	*type = SOAP_TYPE__tev__SeekResponse;
			return soap_in__tev__SeekResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:Seek"))
		{	*type = SOAP_TYPE__tev__Seek;
			return soap_in__tev__Seek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:PullMessagesFaultResponse"))
		{	*type = SOAP_TYPE__tev__PullMessagesFaultResponse;
			return soap_in__tev__PullMessagesFaultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:PullMessagesResponse"))
		{	*type = SOAP_TYPE__tev__PullMessagesResponse;
			return soap_in__tev__PullMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:PullMessages"))
		{	*type = SOAP_TYPE__tev__PullMessages;
			return soap_in__tev__PullMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:CreatePullPointSubscriptionResponse"))
		{	*type = SOAP_TYPE__tev__CreatePullPointSubscriptionResponse;
			return soap_in__tev__CreatePullPointSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:CreatePullPointSubscription"))
		{	*type = SOAP_TYPE__tev__CreatePullPointSubscription;
			return soap_in__tev__CreatePullPointSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetServiceCapabilitiesResponse"))
		{	*type = SOAP_TYPE__tev__GetServiceCapabilitiesResponse;
			return soap_in__tev__GetServiceCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetServiceCapabilities"))
		{	*type = SOAP_TYPE__tev__GetServiceCapabilities;
			return soap_in__tev__GetServiceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ProducerReference"))
		{	*type = SOAP_TYPE__wsnt__ProducerReference;
			return soap_in__wsnt__ProducerReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionReference"))
		{	*type = SOAP_TYPE__wsnt__SubscriptionReference;
			return soap_in__wsnt__SubscriptionReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ConsumerReference"))
		{	*type = SOAP_TYPE__wsnt__ConsumerReference;
			return soap_in__wsnt__ConsumerReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, "");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE__wsnt__TerminationTime:
		return soap_out__wsnt__TerminationTime(soap, "wsnt:TerminationTime", id, (const time_t *)ptr, "");
	case SOAP_TYPE__wsnt__CurrentTime:
		return soap_out__wsnt__CurrentTime(soap, "wsnt:CurrentTime", id, (const time_t *)ptr, "");
	case SOAP_TYPE__wsnt__CreationTime:
		return soap_out__wsnt__CreationTime(soap, "wsnt:CreationTime", id, (const time_t *)ptr, "");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__wstop__topic:
		return soap_out__wstop__topic(soap, "wstop:topic", id, (const bool *)ptr, "");
	case SOAP_TYPE__wsnt__FixedTopicSet:
		return soap_out__wsnt__FixedTopicSet(soap, "wsnt:FixedTopicSet", id, (const bool *)ptr, "");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE__wstop__topicNamespaceLocation:
		return soap_out__wstop__topicNamespaceLocation(soap, "wstop:topicNamespaceLocation", id, (const std::string *)ptr, "");
	case SOAP_TYPE__wstop__TopicSet:
		return soap_out__wstop__TopicSet(soap, "wstop:TopicSet", id, (const wstop__TopicSetType *)ptr, "");
	case SOAP_TYPE__wstop__TopicNamespace:
		return soap_out__wstop__TopicNamespace(soap, "wstop:TopicNamespace", id, (const wstop__TopicNamespaceType *)ptr, "");
	case SOAP_TYPE__wsnt__ResumeFailedFault:
		return soap_out__wsnt__ResumeFailedFault(soap, "wsnt:ResumeFailedFault", id, (const wsnt__ResumeFailedFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__PauseFailedFault:
		return soap_out__wsnt__PauseFailedFault(soap, "wsnt:PauseFailedFault", id, (const wsnt__PauseFailedFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFault:
		return soap_out__wsnt__UnableToDestroySubscriptionFault(soap, "wsnt:UnableToDestroySubscriptionFault", id, (const wsnt__UnableToDestroySubscriptionFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFault:
		return soap_out__wsnt__UnacceptableTerminationTimeFault(soap, "wsnt:UnacceptableTerminationTimeFault", id, (const wsnt__UnacceptableTerminationTimeFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFault:
		return soap_out__wsnt__UnableToCreatePullPointFault(soap, "wsnt:UnableToCreatePullPointFault", id, (const wsnt__UnableToCreatePullPointFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFault:
		return soap_out__wsnt__UnableToDestroyPullPointFault(soap, "wsnt:UnableToDestroyPullPointFault", id, (const wsnt__UnableToDestroyPullPointFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToGetMessagesFault:
		return soap_out__wsnt__UnableToGetMessagesFault(soap, "wsnt:UnableToGetMessagesFault", id, (const wsnt__UnableToGetMessagesFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFault:
		return soap_out__wsnt__NoCurrentMessageOnTopicFault(soap, "wsnt:NoCurrentMessageOnTopicFault", id, (const wsnt__NoCurrentMessageOnTopicFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFault:
		return soap_out__wsnt__UnacceptableInitialTerminationTimeFault(soap, "wsnt:UnacceptableInitialTerminationTimeFault", id, (const wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFault:
		return soap_out__wsnt__NotifyMessageNotSupportedFault(soap, "wsnt:NotifyMessageNotSupportedFault", id, (const wsnt__NotifyMessageNotSupportedFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFault:
		return soap_out__wsnt__UnsupportedPolicyRequestFault(soap, "wsnt:UnsupportedPolicyRequestFault", id, (const wsnt__UnsupportedPolicyRequestFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFault:
		return soap_out__wsnt__UnrecognizedPolicyRequestFault(soap, "wsnt:UnrecognizedPolicyRequestFault", id, (const wsnt__UnrecognizedPolicyRequestFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFault:
		return soap_out__wsnt__InvalidMessageContentExpressionFault(soap, "wsnt:InvalidMessageContentExpressionFault", id, (const wsnt__InvalidMessageContentExpressionFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFault:
		return soap_out__wsnt__InvalidProducerPropertiesExpressionFault(soap, "wsnt:InvalidProducerPropertiesExpressionFault", id, (const wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFault:
		return soap_out__wsnt__MultipleTopicsSpecifiedFault(soap, "wsnt:MultipleTopicsSpecifiedFault", id, (const wsnt__MultipleTopicsSpecifiedFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__TopicNotSupportedFault:
		return soap_out__wsnt__TopicNotSupportedFault(soap, "wsnt:TopicNotSupportedFault", id, (const wsnt__TopicNotSupportedFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFault:
		return soap_out__wsnt__InvalidTopicExpressionFault(soap, "wsnt:InvalidTopicExpressionFault", id, (const wsnt__InvalidTopicExpressionFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFault:
		return soap_out__wsnt__TopicExpressionDialectUnknownFault(soap, "wsnt:TopicExpressionDialectUnknownFault", id, (const wsnt__TopicExpressionDialectUnknownFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidFilterFault:
		return soap_out__wsnt__InvalidFilterFault(soap, "wsnt:InvalidFilterFault", id, (const wsnt__InvalidFilterFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFault:
		return soap_out__wsnt__SubscribeCreationFailedFault(soap, "wsnt:SubscribeCreationFailedFault", id, (const wsnt__SubscribeCreationFailedFaultType *)ptr, "");
	case SOAP_TYPE__wsnt__MessageContent:
		return soap_out__wsnt__MessageContent(soap, "wsnt:MessageContent", id, (const wsnt__QueryExpressionType *)ptr, "");
	case SOAP_TYPE__wsnt__ProducerProperties:
		return soap_out__wsnt__ProducerProperties(soap, "wsnt:ProducerProperties", id, (const wsnt__QueryExpressionType *)ptr, "");
	case SOAP_TYPE__wsnt__NotificationMessage:
		return soap_out__wsnt__NotificationMessage(soap, "wsnt:NotificationMessage", id, (const wsnt__NotificationMessageHolderType *)ptr, "");
	case SOAP_TYPE__wsnt__Topic:
		return soap_out__wsnt__Topic(soap, "wsnt:Topic", id, (const wsnt__TopicExpressionType *)ptr, "");
	case SOAP_TYPE__wsnt__SubscriptionPolicy:
		return soap_out__wsnt__SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", id, (const wsnt__SubscriptionPolicyType *)ptr, "");
	case SOAP_TYPE__wsnt__Filter:
		return soap_out__wsnt__Filter(soap, "wsnt:Filter", id, (const wsnt__FilterType *)ptr, "");
	case SOAP_TYPE__wsnt__TopicExpressionDialect:
		return soap_out__wsnt__TopicExpressionDialect(soap, "wsnt:TopicExpressionDialect", id, (const std::string *)ptr, "");
	case SOAP_TYPE__wsnt__TopicExpression:
		return soap_out__wsnt__TopicExpression(soap, "wsnt:TopicExpression", id, (const wsnt__TopicExpressionType *)ptr, "");
	case SOAP_TYPE__wsrfbf__BaseFault:
		return soap_out__wsrfbf__BaseFault(soap, "wsrfbf:BaseFault", id, (const wsrfbf__BaseFaultType *)ptr, "");
	case SOAP_TYPE__wsrfr__ResourceUnavailableFault:
		return soap_out__wsrfr__ResourceUnavailableFault(soap, "wsrfr:ResourceUnavailableFault", id, (const wsrfr__ResourceUnavailableFaultType *)ptr, "");
	case SOAP_TYPE__wsrfr__ResourceUnknownFault:
		return soap_out__wsrfr__ResourceUnknownFault(soap, "wsrfr:ResourceUnknownFault", id, (const wsrfr__ResourceUnknownFaultType *)ptr, "");
	case SOAP_TYPE__tev__Capabilities:
		return soap_out__tev__Capabilities(soap, "tev:Capabilities", id, (const tev__Capabilities *)ptr, "");
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		return ((_wstop__TopicNamespaceType_Topic *)ptr)->soap_out(soap, "wstop:TopicNamespaceType-Topic", id, "");
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		return ((_wsnt__Subscribe_SubscriptionPolicy *)ptr)->soap_out(soap, "wsnt:Subscribe-SubscriptionPolicy", id, "");
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		return ((_wsnt__NotificationMessageHolderType_Message *)ptr)->soap_out(soap, "wsnt:NotificationMessageHolderType-Message", id, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		return ((_wsrfbf__BaseFaultType_FaultCause *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-FaultCause", id, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		return ((_wsrfbf__BaseFaultType_Description *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-Description", id, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		return ((_wsrfbf__BaseFaultType_ErrorCode *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-ErrorCode", id, "");
	case SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy:
		return ((_tev__CreatePullPointSubscription_SubscriptionPolicy *)ptr)->soap_out(soap, "tev:CreatePullPointSubscription-SubscriptionPolicy", id, "");
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		return soap_out_wstop__SimpleTopicExpression(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, (const std::string *)ptr, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_wstop__FullTopicExpression:
		return soap_out_wstop__FullTopicExpression(soap, tag, id, (const std::string *)ptr, "wstop:FullTopicExpression");
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		return soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag, id, (const std::string *)ptr, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_wstop__TopicSetType:
		return ((wstop__TopicSetType *)ptr)->soap_out(soap, tag, id, "wstop:TopicSetType");
	case SOAP_TYPE_wstop__TopicType:
		return ((wstop__TopicType *)ptr)->soap_out(soap, tag, id, "wstop:TopicType");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return ((wstop__TopicNamespaceType *)ptr)->soap_out(soap, tag, id, "wstop:TopicNamespaceType");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return ((wstop__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return ((wstop__ExtensibleDocumented *)ptr)->soap_out(soap, tag, id, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return ((wstop__Documentation *)ptr)->soap_out(soap, tag, id, "wstop:Documentation");
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		return ((_wsnt__ResumeSubscriptionResponse *)ptr)->soap_out(soap, "wsnt:ResumeSubscriptionResponse", id, "");
	case SOAP_TYPE__wsnt__ResumeSubscription:
		return ((_wsnt__ResumeSubscription *)ptr)->soap_out(soap, "wsnt:ResumeSubscription", id, "");
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		return ((_wsnt__PauseSubscriptionResponse *)ptr)->soap_out(soap, "wsnt:PauseSubscriptionResponse", id, "");
	case SOAP_TYPE__wsnt__PauseSubscription:
		return ((_wsnt__PauseSubscription *)ptr)->soap_out(soap, "wsnt:PauseSubscription", id, "");
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		return ((_wsnt__UnsubscribeResponse *)ptr)->soap_out(soap, "wsnt:UnsubscribeResponse", id, "");
	case SOAP_TYPE__wsnt__Unsubscribe:
		return ((_wsnt__Unsubscribe *)ptr)->soap_out(soap, "wsnt:Unsubscribe", id, "");
	case SOAP_TYPE__wsnt__RenewResponse:
		return ((_wsnt__RenewResponse *)ptr)->soap_out(soap, "wsnt:RenewResponse", id, "");
	case SOAP_TYPE__wsnt__Renew:
		return ((_wsnt__Renew *)ptr)->soap_out(soap, "wsnt:Renew", id, "");
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		return ((_wsnt__CreatePullPointResponse *)ptr)->soap_out(soap, "wsnt:CreatePullPointResponse", id, "");
	case SOAP_TYPE__wsnt__CreatePullPoint:
		return ((_wsnt__CreatePullPoint *)ptr)->soap_out(soap, "wsnt:CreatePullPoint", id, "");
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		return ((_wsnt__DestroyPullPointResponse *)ptr)->soap_out(soap, "wsnt:DestroyPullPointResponse", id, "");
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		return ((_wsnt__DestroyPullPoint *)ptr)->soap_out(soap, "wsnt:DestroyPullPoint", id, "");
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		return ((_wsnt__GetMessagesResponse *)ptr)->soap_out(soap, "wsnt:GetMessagesResponse", id, "");
	case SOAP_TYPE__wsnt__GetMessages:
		return ((_wsnt__GetMessages *)ptr)->soap_out(soap, "wsnt:GetMessages", id, "");
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		return ((_wsnt__GetCurrentMessageResponse *)ptr)->soap_out(soap, "wsnt:GetCurrentMessageResponse", id, "");
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		return ((_wsnt__GetCurrentMessage *)ptr)->soap_out(soap, "wsnt:GetCurrentMessage", id, "");
	case SOAP_TYPE__wsnt__SubscribeResponse:
		return ((_wsnt__SubscribeResponse *)ptr)->soap_out(soap, "wsnt:SubscribeResponse", id, "");
	case SOAP_TYPE__wsnt__Subscribe:
		return ((_wsnt__Subscribe *)ptr)->soap_out(soap, "wsnt:Subscribe", id, "");
	case SOAP_TYPE__wsnt__UseRaw:
		return ((_wsnt__UseRaw *)ptr)->soap_out(soap, "wsnt:UseRaw", id, "");
	case SOAP_TYPE__wsnt__Notify:
		return ((_wsnt__Notify *)ptr)->soap_out(soap, "wsnt:Notify", id, "");
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		return ((_wsnt__SubscriptionManagerRP *)ptr)->soap_out(soap, "wsnt:SubscriptionManagerRP", id, "");
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		return ((_wsnt__NotificationProducerRP *)ptr)->soap_out(soap, "wsnt:NotificationProducerRP", id, "");
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return ((wsnt__ResumeFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return ((wsnt__PauseFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return ((wsnt__UnableToDestroySubscriptionFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return ((wsnt__UnacceptableTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return ((wsnt__UnableToCreatePullPointFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return ((wsnt__UnableToDestroyPullPointFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return ((wsnt__UnableToGetMessagesFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return ((wsnt__NoCurrentMessageOnTopicFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return ((wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return ((wsnt__NotifyMessageNotSupportedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return ((wsnt__UnsupportedPolicyRequestFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return ((wsnt__UnrecognizedPolicyRequestFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return ((wsnt__InvalidMessageContentExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return ((wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return ((wsnt__MultipleTopicsSpecifiedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return ((wsnt__TopicNotSupportedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return ((wsnt__InvalidTopicExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return ((wsnt__TopicExpressionDialectUnknownFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return ((wsnt__InvalidFilterFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return ((wsnt__SubscribeCreationFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return ((wsnt__NotificationMessageHolderType *)ptr)->soap_out(soap, tag, id, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return ((wsnt__SubscriptionPolicyType *)ptr)->soap_out(soap, tag, id, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_wsnt__FilterType:
		return ((wsnt__FilterType *)ptr)->soap_out(soap, tag, id, "wsnt:FilterType");
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return ((wsnt__TopicExpressionType *)ptr)->soap_out(soap, tag, id, "wsnt:TopicExpressionType");
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return ((wsnt__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "wsnt:QueryExpressionType");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return ((wsrfbf__BaseFaultType *)ptr)->soap_out(soap, tag, id, "wsrfbf:BaseFaultType");
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		return ((wsrfr__ResourceUnavailableFaultType *)ptr)->soap_out(soap, tag, id, "wsrfr:ResourceUnavailableFaultType");
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		return ((wsrfr__ResourceUnknownFaultType *)ptr)->soap_out(soap, tag, id, "wsrfr:ResourceUnknownFaultType");
	case SOAP_TYPE__tev__GetEventPropertiesResponse:
		return ((_tev__GetEventPropertiesResponse *)ptr)->soap_out(soap, "tev:GetEventPropertiesResponse", id, "");
	case SOAP_TYPE__tev__GetEventProperties:
		return ((_tev__GetEventProperties *)ptr)->soap_out(soap, "tev:GetEventProperties", id, "");
	case SOAP_TYPE__tev__SetSynchronizationPointResponse:
		return ((_tev__SetSynchronizationPointResponse *)ptr)->soap_out(soap, "tev:SetSynchronizationPointResponse", id, "");
	case SOAP_TYPE__tev__SetSynchronizationPoint:
		return ((_tev__SetSynchronizationPoint *)ptr)->soap_out(soap, "tev:SetSynchronizationPoint", id, "");
	case SOAP_TYPE__tev__SeekResponse:
		return ((_tev__SeekResponse *)ptr)->soap_out(soap, "tev:SeekResponse", id, "");
	case SOAP_TYPE__tev__Seek:
		return ((_tev__Seek *)ptr)->soap_out(soap, "tev:Seek", id, "");
	case SOAP_TYPE__tev__PullMessagesFaultResponse:
		return ((_tev__PullMessagesFaultResponse *)ptr)->soap_out(soap, "tev:PullMessagesFaultResponse", id, "");
	case SOAP_TYPE__tev__PullMessagesResponse:
		return ((_tev__PullMessagesResponse *)ptr)->soap_out(soap, "tev:PullMessagesResponse", id, "");
	case SOAP_TYPE__tev__PullMessages:
		return ((_tev__PullMessages *)ptr)->soap_out(soap, "tev:PullMessages", id, "");
	case SOAP_TYPE__tev__CreatePullPointSubscriptionResponse:
		return ((_tev__CreatePullPointSubscriptionResponse *)ptr)->soap_out(soap, "tev:CreatePullPointSubscriptionResponse", id, "");
	case SOAP_TYPE__tev__CreatePullPointSubscription:
		return ((_tev__CreatePullPointSubscription *)ptr)->soap_out(soap, "tev:CreatePullPointSubscription", id, "");
	case SOAP_TYPE__tev__GetServiceCapabilitiesResponse:
		return ((_tev__GetServiceCapabilitiesResponse *)ptr)->soap_out(soap, "tev:GetServiceCapabilitiesResponse", id, "");
	case SOAP_TYPE__tev__GetServiceCapabilities:
		return ((_tev__GetServiceCapabilities *)ptr)->soap_out(soap, "tev:GetServiceCapabilities", id, "");
	case SOAP_TYPE_tev__Capabilities:
		return ((tev__Capabilities *)ptr)->soap_out(soap, tag, id, "tev:Capabilities");
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::string *)ptr, "");
	case SOAP_TYPE_xsd__token:
		return soap_out_xsd__token(soap, tag, id, (const std::string *)ptr, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE__wsnt__ProducerReference:
		return soap_out__wsnt__ProducerReference(soap, "wsnt:ProducerReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsnt__SubscriptionReference:
		return soap_out__wsnt__SubscriptionReference(soap, "wsnt:SubscriptionReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsnt__ConsumerReference:
		return soap_out__wsnt__ConsumerReference(soap, "wsnt:ConsumerReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, "");
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, "");
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, "");
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, "");
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscription:
		return soap_out_PointerTo_wsnt__ResumeSubscription(soap, tag, id, (_wsnt__ResumeSubscription *const*)ptr, "wsnt:ResumeSubscription");
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscription:
		return soap_out_PointerTo_wsnt__PauseSubscription(soap, tag, id, (_wsnt__PauseSubscription *const*)ptr, "wsnt:PauseSubscription");
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPoint:
		return soap_out_PointerTo_wsnt__CreatePullPoint(soap, tag, id, (_wsnt__CreatePullPoint *const*)ptr, "wsnt:CreatePullPoint");
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint:
		return soap_out_PointerTo_wsnt__DestroyPullPoint(soap, tag, id, (_wsnt__DestroyPullPoint *const*)ptr, "wsnt:DestroyPullPoint");
	case SOAP_TYPE_PointerTo_wsnt__GetMessages:
		return soap_out_PointerTo_wsnt__GetMessages(soap, tag, id, (_wsnt__GetMessages *const*)ptr, "wsnt:GetMessages");
	case SOAP_TYPE_PointerTo_wsnt__Notify:
		return soap_out_PointerTo_wsnt__Notify(soap, tag, id, (_wsnt__Notify *const*)ptr, "wsnt:Notify");
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage:
		return soap_out_PointerTo_wsnt__GetCurrentMessage(soap, tag, id, (_wsnt__GetCurrentMessage *const*)ptr, "wsnt:GetCurrentMessage");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe:
		return soap_out_PointerTo_wsnt__Subscribe(soap, tag, id, (_wsnt__Subscribe *const*)ptr, "wsnt:Subscribe");
	case SOAP_TYPE_PointerTo_wsnt__Renew:
		return soap_out_PointerTo_wsnt__Renew(soap, tag, id, (_wsnt__Renew *const*)ptr, "wsnt:Renew");
	case SOAP_TYPE_PointerTo_tev__GetEventProperties:
		return soap_out_PointerTo_tev__GetEventProperties(soap, tag, id, (_tev__GetEventProperties *const*)ptr, "tev:GetEventProperties");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription:
		return soap_out_PointerTo_tev__CreatePullPointSubscription(soap, tag, id, (_tev__CreatePullPointSubscription *const*)ptr, "tev:CreatePullPointSubscription");
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilities:
		return soap_out_PointerTo_tev__GetServiceCapabilities(soap, tag, id, (_tev__GetServiceCapabilities *const*)ptr, "tev:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_wsnt__Unsubscribe:
		return soap_out_PointerTo_wsnt__Unsubscribe(soap, tag, id, (_wsnt__Unsubscribe *const*)ptr, "wsnt:Unsubscribe");
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint:
		return soap_out_PointerTo_tev__SetSynchronizationPoint(soap, tag, id, (_tev__SetSynchronizationPoint *const*)ptr, "tev:SetSynchronizationPoint");
	case SOAP_TYPE_PointerTo_tev__Seek:
		return soap_out_PointerTo_tev__Seek(soap, tag, id, (_tev__Seek *const*)ptr, "tev:Seek");
	case SOAP_TYPE_PointerTo_tev__PullMessages:
		return soap_out_PointerTo_tev__PullMessages(soap, tag, id, (_tev__PullMessages *const*)ptr, "tev:PullMessages");
	case SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType:
		return soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, (wsnt__UnsupportedPolicyRequestFaultType *const*)ptr, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType:
		return soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, (wsnt__UnrecognizedPolicyRequestFaultType *const*)ptr, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType:
		return soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, (wsnt__UnacceptableTerminationTimeFaultType *const*)ptr, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, (wsnt__UnacceptableInitialTerminationTimeFaultType *const*)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType:
		return soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag, id, (wsnt__UnableToGetMessagesFaultType *const*)ptr, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType:
		return soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, (wsnt__UnableToDestroySubscriptionFaultType *const*)ptr, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType:
		return soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag, id, (wsnt__UnableToDestroyPullPointFaultType *const*)ptr, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType:
		return soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag, id, (wsnt__UnableToCreatePullPointFaultType *const*)ptr, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType:
		return soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, tag, id, (wsnt__TopicNotSupportedFaultType *const*)ptr, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType:
		return soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, (wsnt__TopicExpressionDialectUnknownFaultType *const*)ptr, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType:
		return soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag, id, (wsnt__SubscribeCreationFailedFaultType *const*)ptr, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType:
		return soap_out_PointerTowsnt__ResumeFailedFaultType(soap, tag, id, (wsnt__ResumeFailedFaultType *const*)ptr, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType:
		return soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, tag, id, (wsrfr__ResourceUnknownFaultType *const*)ptr, "wsrfr:ResourceUnknownFaultType");
	case SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse:
		return soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, tag, id, (_tev__PullMessagesFaultResponse *const*)ptr, "tev:PullMessagesFaultResponse");
	case SOAP_TYPE_PointerTowsnt__PauseFailedFaultType:
		return soap_out_PointerTowsnt__PauseFailedFaultType(soap, tag, id, (wsnt__PauseFailedFaultType *const*)ptr, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType:
		return soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, (wsnt__NotifyMessageNotSupportedFaultType *const*)ptr, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType:
		return soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, (wsnt__NoCurrentMessageOnTopicFaultType *const*)ptr, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType:
		return soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, (wsnt__MultipleTopicsSpecifiedFaultType *const*)ptr, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType:
		return soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag, id, (wsnt__InvalidTopicExpressionFaultType *const*)ptr, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, (wsnt__InvalidProducerPropertiesExpressionFaultType *const*)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType:
		return soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, (wsnt__InvalidMessageContentExpressionFaultType *const*)ptr, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType:
		return soap_out_PointerTowsnt__InvalidFilterFaultType(soap, tag, id, (wsnt__InvalidFilterFaultType *const*)ptr, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_out_PointerToxsd__NCName(soap, tag, id, (std::string *const*)ptr, "xsd:NCName");
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		return soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag, id, (std::string *const*)ptr, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_out_PointerToxsd__QName(soap, tag, id, (std::string *const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_out_PointerTowstop__TopicType(soap, tag, id, (wstop__TopicType *const*)ptr, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_out_PointerTowstop__QueryExpressionType(soap, tag, id, (wstop__QueryExpressionType *const*)ptr, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_out_PointerTowstop__Documentation(soap, tag, id, (wstop__Documentation *const*)ptr, "wstop:Documentation");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::string *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		return soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, (_wsnt__Subscribe_SubscriptionPolicy *const*)ptr, "wsnt:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		return soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag, id, (wsnt__SubscriptionPolicyType *const*)ptr, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		return soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, (wsnt__TopicExpressionType *const*)ptr, "wsnt:TopicExpressionType");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, id, (_wsrfbf__BaseFaultType_FaultCause *const*)ptr, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_out_PointerTo_xml__lang(soap, tag, id, (std::string *const*)ptr, "xml:lang");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, (_wsrfbf__BaseFaultType_ErrorCode *const*)ptr, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_out_PointerTowsa5__EndpointReferenceType(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_out_PointerTowstop__TopicSetType(soap, tag, id, (wstop__TopicSetType *const*)ptr, "wstop:TopicSetType");
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, (wsnt__NotificationMessageHolderType *const*)ptr, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy:
		return soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, id, (_tev__CreatePullPointSubscription_SubscriptionPolicy *const*)ptr, "tev:CreatePullPointSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType:
		return soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag, id, (std::string *const*)ptr, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTowsnt__FilterType:
		return soap_out_PointerTowsnt__FilterType(soap, tag, id, (wsnt__FilterType *const*)ptr, "wsnt:FilterType");
	case SOAP_TYPE_PointerTotev__Capabilities:
		return soap_out_PointerTotev__Capabilities(soap, tag, id, (tev__Capabilities *const*)ptr, "tev:Capabilities");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__wstop__topicNamespaceLocation:
		soap_serialize__wstop__topicNamespaceLocation(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__wstop__TopicSet:
		soap_serialize__wstop__TopicSet(soap, (const wstop__TopicSetType *)ptr);
		break;
	case SOAP_TYPE__wstop__TopicNamespace:
		soap_serialize__wstop__TopicNamespace(soap, (const wstop__TopicNamespaceType *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFault:
		soap_serialize__wsnt__ResumeFailedFault(soap, (const wsnt__ResumeFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseFailedFault:
		soap_serialize__wsnt__PauseFailedFault(soap, (const wsnt__PauseFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFault:
		soap_serialize__wsnt__UnableToDestroySubscriptionFault(soap, (const wsnt__UnableToDestroySubscriptionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFault:
		soap_serialize__wsnt__UnacceptableTerminationTimeFault(soap, (const wsnt__UnacceptableTerminationTimeFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFault:
		soap_serialize__wsnt__UnableToCreatePullPointFault(soap, (const wsnt__UnableToCreatePullPointFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFault:
		soap_serialize__wsnt__UnableToDestroyPullPointFault(soap, (const wsnt__UnableToDestroyPullPointFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFault:
		soap_serialize__wsnt__UnableToGetMessagesFault(soap, (const wsnt__UnableToGetMessagesFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFault:
		soap_serialize__wsnt__NoCurrentMessageOnTopicFault(soap, (const wsnt__NoCurrentMessageOnTopicFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFault:
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFault(soap, (const wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFault:
		soap_serialize__wsnt__NotifyMessageNotSupportedFault(soap, (const wsnt__NotifyMessageNotSupportedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFault:
		soap_serialize__wsnt__UnsupportedPolicyRequestFault(soap, (const wsnt__UnsupportedPolicyRequestFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFault:
		soap_serialize__wsnt__UnrecognizedPolicyRequestFault(soap, (const wsnt__UnrecognizedPolicyRequestFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFault:
		soap_serialize__wsnt__InvalidMessageContentExpressionFault(soap, (const wsnt__InvalidMessageContentExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFault:
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFault(soap, (const wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFault:
		soap_serialize__wsnt__MultipleTopicsSpecifiedFault(soap, (const wsnt__MultipleTopicsSpecifiedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFault:
		soap_serialize__wsnt__TopicNotSupportedFault(soap, (const wsnt__TopicNotSupportedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFault:
		soap_serialize__wsnt__InvalidTopicExpressionFault(soap, (const wsnt__InvalidTopicExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFault:
		soap_serialize__wsnt__TopicExpressionDialectUnknownFault(soap, (const wsnt__TopicExpressionDialectUnknownFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFault:
		soap_serialize__wsnt__InvalidFilterFault(soap, (const wsnt__InvalidFilterFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFault:
		soap_serialize__wsnt__SubscribeCreationFailedFault(soap, (const wsnt__SubscribeCreationFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__MessageContent:
		soap_serialize__wsnt__MessageContent(soap, (const wsnt__QueryExpressionType *)ptr);
		break;
	case SOAP_TYPE__wsnt__ProducerProperties:
		soap_serialize__wsnt__ProducerProperties(soap, (const wsnt__QueryExpressionType *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotificationMessage:
		soap_serialize__wsnt__NotificationMessage(soap, (const wsnt__NotificationMessageHolderType *)ptr);
		break;
	case SOAP_TYPE__wsnt__Topic:
		soap_serialize__wsnt__Topic(soap, (const wsnt__TopicExpressionType *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscriptionPolicy:
		soap_serialize__wsnt__SubscriptionPolicy(soap, (const wsnt__SubscriptionPolicyType *)ptr);
		break;
	case SOAP_TYPE__wsnt__Filter:
		soap_serialize__wsnt__Filter(soap, (const wsnt__FilterType *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialect:
		soap_serialize__wsnt__TopicExpressionDialect(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpression:
		soap_serialize__wsnt__TopicExpression(soap, (const wsnt__TopicExpressionType *)ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFault:
		soap_serialize__wsrfbf__BaseFault(soap, (const wsrfbf__BaseFaultType *)ptr);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnavailableFault:
		soap_serialize__wsrfr__ResourceUnavailableFault(soap, (const wsrfr__ResourceUnavailableFaultType *)ptr);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnknownFault:
		soap_serialize__wsrfr__ResourceUnknownFault(soap, (const wsrfr__ResourceUnknownFaultType *)ptr);
		break;
	case SOAP_TYPE__tev__Capabilities:
		soap_serialize__tev__Capabilities(soap, (const tev__Capabilities *)ptr);
		break;
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		((_wstop__TopicNamespaceType_Topic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		((_wsnt__Subscribe_SubscriptionPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		((_wsnt__NotificationMessageHolderType_Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		((_wsrfbf__BaseFaultType_FaultCause *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		((_wsrfbf__BaseFaultType_Description *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		((_wsrfbf__BaseFaultType_ErrorCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy:
		((_tev__CreatePullPointSubscription_SubscriptionPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		soap_serialize_wstop__SimpleTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		soap_serialize_wstop__ConcreteTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wstop__FullTopicExpression:
		soap_serialize_wstop__FullTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		((wstop__TopicSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__TopicType:
		((wstop__TopicType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		((wstop__TopicNamespaceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		((wstop__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		((wstop__ExtensibleDocumented *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__Documentation:
		((wstop__Documentation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		((_wsnt__ResumeSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscription:
		((_wsnt__ResumeSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		((_wsnt__PauseSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__PauseSubscription:
		((_wsnt__PauseSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		((_wsnt__UnsubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Unsubscribe:
		((_wsnt__Unsubscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__RenewResponse:
		((_wsnt__RenewResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Renew:
		((_wsnt__Renew *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		((_wsnt__CreatePullPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__CreatePullPoint:
		((_wsnt__CreatePullPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		((_wsnt__DestroyPullPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		((_wsnt__DestroyPullPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		((_wsnt__GetMessagesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__GetMessages:
		((_wsnt__GetMessages *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		((_wsnt__GetCurrentMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		((_wsnt__GetCurrentMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__SubscribeResponse:
		((_wsnt__SubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Subscribe:
		((_wsnt__Subscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__UseRaw:
		((_wsnt__UseRaw *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__Notify:
		((_wsnt__Notify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		((_wsnt__SubscriptionManagerRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		((_wsnt__NotificationProducerRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		((wsnt__ResumeFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		((wsnt__PauseFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		((wsnt__UnableToDestroySubscriptionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		((wsnt__UnacceptableTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		((wsnt__UnableToCreatePullPointFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		((wsnt__UnableToDestroyPullPointFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		((wsnt__UnableToGetMessagesFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		((wsnt__NoCurrentMessageOnTopicFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		((wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		((wsnt__NotifyMessageNotSupportedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		((wsnt__UnsupportedPolicyRequestFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		((wsnt__UnrecognizedPolicyRequestFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		((wsnt__InvalidMessageContentExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		((wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		((wsnt__MultipleTopicsSpecifiedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		((wsnt__TopicNotSupportedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		((wsnt__InvalidTopicExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		((wsnt__TopicExpressionDialectUnknownFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		((wsnt__InvalidFilterFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		((wsnt__SubscribeCreationFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		((wsnt__NotificationMessageHolderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		((wsnt__SubscriptionPolicyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__FilterType:
		((wsnt__FilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionType:
		((wsnt__TopicExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnt__QueryExpressionType:
		((wsnt__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		((wsrfbf__BaseFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		((wsrfr__ResourceUnavailableFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		((wsrfr__ResourceUnknownFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__GetEventPropertiesResponse:
		((_tev__GetEventPropertiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__GetEventProperties:
		((_tev__GetEventProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__SetSynchronizationPointResponse:
		((_tev__SetSynchronizationPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__SetSynchronizationPoint:
		((_tev__SetSynchronizationPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__SeekResponse:
		((_tev__SeekResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__Seek:
		((_tev__Seek *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__PullMessagesFaultResponse:
		((_tev__PullMessagesFaultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__PullMessagesResponse:
		((_tev__PullMessagesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__PullMessages:
		((_tev__PullMessages *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscriptionResponse:
		((_tev__CreatePullPointSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscription:
		((_tev__CreatePullPointSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__GetServiceCapabilitiesResponse:
		((_tev__GetServiceCapabilitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tev__GetServiceCapabilities:
		((_tev__GetServiceCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tev__Capabilities:
		((tev__Capabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_xsd__token(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tev__ResumeSubscription:
		soap_serialize___tev__ResumeSubscription(soap, (const struct __tev__ResumeSubscription *)ptr);
		break;
	case SOAP_TYPE___tev__PauseSubscription:
		soap_serialize___tev__PauseSubscription(soap, (const struct __tev__PauseSubscription *)ptr);
		break;
	case SOAP_TYPE___tev__Unsubscribe__:
		soap_serialize___tev__Unsubscribe__(soap, (const struct __tev__Unsubscribe__ *)ptr);
		break;
	case SOAP_TYPE___tev__Renew_:
		soap_serialize___tev__Renew_(soap, (const struct __tev__Renew_ *)ptr);
		break;
	case SOAP_TYPE___tev__CreatePullPoint:
		soap_serialize___tev__CreatePullPoint(soap, (const struct __tev__CreatePullPoint *)ptr);
		break;
	case SOAP_TYPE___tev__Notify_:
		soap_serialize___tev__Notify_(soap, (const struct __tev__Notify_ *)ptr);
		break;
	case SOAP_TYPE___tev__DestroyPullPoint:
		soap_serialize___tev__DestroyPullPoint(soap, (const struct __tev__DestroyPullPoint *)ptr);
		break;
	case SOAP_TYPE___tev__GetMessages:
		soap_serialize___tev__GetMessages(soap, (const struct __tev__GetMessages *)ptr);
		break;
	case SOAP_TYPE___tev__Notify:
		soap_serialize___tev__Notify(soap, (const struct __tev__Notify *)ptr);
		break;
	case SOAP_TYPE___tev__GetCurrentMessage:
		soap_serialize___tev__GetCurrentMessage(soap, (const struct __tev__GetCurrentMessage *)ptr);
		break;
	case SOAP_TYPE___tev__Subscribe:
		soap_serialize___tev__Subscribe(soap, (const struct __tev__Subscribe *)ptr);
		break;
	case SOAP_TYPE___tev__Unsubscribe_:
		soap_serialize___tev__Unsubscribe_(soap, (const struct __tev__Unsubscribe_ *)ptr);
		break;
	case SOAP_TYPE___tev__Renew:
		soap_serialize___tev__Renew(soap, (const struct __tev__Renew *)ptr);
		break;
	case SOAP_TYPE___tev__GetEventProperties:
		soap_serialize___tev__GetEventProperties(soap, (const struct __tev__GetEventProperties *)ptr);
		break;
	case SOAP_TYPE___tev__CreatePullPointSubscription:
		soap_serialize___tev__CreatePullPointSubscription(soap, (const struct __tev__CreatePullPointSubscription *)ptr);
		break;
	case SOAP_TYPE___tev__GetServiceCapabilities:
		soap_serialize___tev__GetServiceCapabilities(soap, (const struct __tev__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE___tev__Unsubscribe:
		soap_serialize___tev__Unsubscribe(soap, (const struct __tev__Unsubscribe *)ptr);
		break;
	case SOAP_TYPE___tev__SetSynchronizationPoint:
		soap_serialize___tev__SetSynchronizationPoint(soap, (const struct __tev__SetSynchronizationPoint *)ptr);
		break;
	case SOAP_TYPE___tev__Seek:
		soap_serialize___tev__Seek(soap, (const struct __tev__Seek *)ptr);
		break;
	case SOAP_TYPE___tev__PullMessages:
		soap_serialize___tev__PullMessages(soap, (const struct __tev__PullMessages *)ptr);
		break;
	case SOAP_TYPE__wsnt__ProducerReference:
		soap_serialize__wsnt__ProducerReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscriptionReference:
		soap_serialize__wsnt__SubscriptionReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsnt__ConsumerReference:
		soap_serialize__wsnt__ConsumerReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscription:
		soap_serialize_PointerTo_wsnt__ResumeSubscription(soap, (_wsnt__ResumeSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscription:
		soap_serialize_PointerTo_wsnt__PauseSubscription(soap, (_wsnt__PauseSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPoint:
		soap_serialize_PointerTo_wsnt__CreatePullPoint(soap, (_wsnt__CreatePullPoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint:
		soap_serialize_PointerTo_wsnt__DestroyPullPoint(soap, (_wsnt__DestroyPullPoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__GetMessages:
		soap_serialize_PointerTo_wsnt__GetMessages(soap, (_wsnt__GetMessages *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Notify:
		soap_serialize_PointerTo_wsnt__Notify(soap, (_wsnt__Notify *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage:
		soap_serialize_PointerTo_wsnt__GetCurrentMessage(soap, (_wsnt__GetCurrentMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Subscribe:
		soap_serialize_PointerTo_wsnt__Subscribe(soap, (_wsnt__Subscribe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Renew:
		soap_serialize_PointerTo_wsnt__Renew(soap, (_wsnt__Renew *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__GetEventProperties:
		soap_serialize_PointerTo_tev__GetEventProperties(soap, (_tev__GetEventProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription:
		soap_serialize_PointerTo_tev__CreatePullPointSubscription(soap, (_tev__CreatePullPointSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilities:
		soap_serialize_PointerTo_tev__GetServiceCapabilities(soap, (_tev__GetServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Unsubscribe:
		soap_serialize_PointerTo_wsnt__Unsubscribe(soap, (_wsnt__Unsubscribe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint:
		soap_serialize_PointerTo_tev__SetSynchronizationPoint(soap, (_tev__SetSynchronizationPoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__Seek:
		soap_serialize_PointerTo_tev__Seek(soap, (_tev__Seek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__PullMessages:
		soap_serialize_PointerTo_tev__PullMessages(soap, (_tev__PullMessages *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType:
		soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, (wsnt__UnsupportedPolicyRequestFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType:
		soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, (wsnt__UnrecognizedPolicyRequestFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType:
		soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, (wsnt__UnacceptableTerminationTimeFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType:
		soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, (wsnt__UnacceptableInitialTerminationTimeFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType:
		soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(soap, (wsnt__UnableToGetMessagesFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType:
		soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, (wsnt__UnableToDestroySubscriptionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType:
		soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, (wsnt__UnableToDestroyPullPointFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType:
		soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(soap, (wsnt__UnableToCreatePullPointFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType:
		soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(soap, (wsnt__TopicNotSupportedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType:
		soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, (wsnt__TopicExpressionDialectUnknownFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType:
		soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(soap, (wsnt__SubscribeCreationFailedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType:
		soap_serialize_PointerTowsnt__ResumeFailedFaultType(soap, (wsnt__ResumeFailedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType:
		soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(soap, (wsrfr__ResourceUnknownFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse:
		soap_serialize_PointerTo_tev__PullMessagesFaultResponse(soap, (_tev__PullMessagesFaultResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__PauseFailedFaultType:
		soap_serialize_PointerTowsnt__PauseFailedFaultType(soap, (wsnt__PauseFailedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType:
		soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, (wsnt__NotifyMessageNotSupportedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType:
		soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, (wsnt__NoCurrentMessageOnTopicFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType:
		soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, (wsnt__MultipleTopicsSpecifiedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType:
		soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(soap, (wsnt__InvalidTopicExpressionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType:
		soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, (wsnt__InvalidProducerPropertiesExpressionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType:
		soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, (wsnt__InvalidMessageContentExpressionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType:
		soap_serialize_PointerTowsnt__InvalidFilterFaultType(soap, (wsnt__InvalidFilterFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NCName:
		soap_serialize_PointerToxsd__NCName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		soap_serialize_PointerTowstop__ConcreteTopicExpression(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__QName:
		soap_serialize_PointerToxsd__QName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicType:
		soap_serialize_PointerTowstop__TopicType(soap, (wstop__TopicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		soap_serialize_PointerTowstop__QueryExpressionType(soap, (wstop__QueryExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__Documentation:
		soap_serialize_PointerTowstop__Documentation(soap, (wstop__Documentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, (_wsnt__Subscribe_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, (wsnt__SubscriptionPolicyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, (wsnt__TopicExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, (_wsrfbf__BaseFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xml__lang:
		soap_serialize_PointerTo_xml__lang(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, (_wsrfbf__BaseFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		soap_serialize_PointerTowsa5__EndpointReferenceType(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		soap_serialize_PointerTowstop__TopicSetType(soap, (wstop__TopicSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, (wsnt__NotificationMessageHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy:
		soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, (_tev__CreatePullPointSubscription_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType:
		soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__FilterType:
		soap_serialize_PointerTowsnt__FilterType(soap, (wsnt__FilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotev__Capabilities:
		soap_serialize_PointerTotev__Capabilities(soap, (tev__Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)soap_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)soap_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)soap_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)soap_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)soap_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_chan__ChannelInstanceType:
		return (void*)soap_instantiate_chan__ChannelInstanceType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tev__Capabilities:
		return (void*)soap_instantiate_tev__Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__GetServiceCapabilities:
		return (void*)soap_instantiate__tev__GetServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__GetServiceCapabilitiesResponse:
		return (void*)soap_instantiate__tev__GetServiceCapabilitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy:
		return (void*)soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__CreatePullPointSubscription:
		return (void*)soap_instantiate__tev__CreatePullPointSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__CreatePullPointSubscriptionResponse:
		return (void*)soap_instantiate__tev__CreatePullPointSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__PullMessages:
		return (void*)soap_instantiate__tev__PullMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__PullMessagesResponse:
		return (void*)soap_instantiate__tev__PullMessagesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__PullMessagesFaultResponse:
		return (void*)soap_instantiate__tev__PullMessagesFaultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__Seek:
		return (void*)soap_instantiate__tev__Seek(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__SeekResponse:
		return (void*)soap_instantiate__tev__SeekResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__SetSynchronizationPoint:
		return (void*)soap_instantiate__tev__SetSynchronizationPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__SetSynchronizationPointResponse:
		return (void*)soap_instantiate__tev__SetSynchronizationPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__GetEventProperties:
		return (void*)soap_instantiate__tev__GetEventProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__GetEventPropertiesResponse:
		return (void*)soap_instantiate__tev__GetEventPropertiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		return (void*)soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		return (void*)soap_instantiate__wsrfbf__BaseFaultType_Description(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		return (void*)soap_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return (void*)soap_instantiate_wsrfbf__BaseFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return (void*)soap_instantiate_wsnt__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return (void*)soap_instantiate_wsnt__TopicExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__FilterType:
		return (void*)soap_instantiate_wsnt__FilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return (void*)soap_instantiate_wsnt__SubscriptionPolicyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		return (void*)soap_instantiate__wsnt__NotificationMessageHolderType_Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return (void*)soap_instantiate_wsnt__NotificationMessageHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		return (void*)soap_instantiate__wsnt__NotificationProducerRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		return (void*)soap_instantiate__wsnt__SubscriptionManagerRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Notify:
		return (void*)soap_instantiate__wsnt__Notify(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UseRaw:
		return (void*)soap_instantiate__wsnt__UseRaw(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		return (void*)soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Subscribe:
		return (void*)soap_instantiate__wsnt__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__SubscribeResponse:
		return (void*)soap_instantiate__wsnt__SubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		return (void*)soap_instantiate__wsnt__GetCurrentMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		return (void*)soap_instantiate__wsnt__GetCurrentMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__GetMessages:
		return (void*)soap_instantiate__wsnt__GetMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		return (void*)soap_instantiate__wsnt__GetMessagesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		return (void*)soap_instantiate__wsnt__DestroyPullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		return (void*)soap_instantiate__wsnt__DestroyPullPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__CreatePullPoint:
		return (void*)soap_instantiate__wsnt__CreatePullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		return (void*)soap_instantiate__wsnt__CreatePullPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Renew:
		return (void*)soap_instantiate__wsnt__Renew(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__RenewResponse:
		return (void*)soap_instantiate__wsnt__RenewResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Unsubscribe:
		return (void*)soap_instantiate__wsnt__Unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		return (void*)soap_instantiate__wsnt__UnsubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__PauseSubscription:
		return (void*)soap_instantiate__wsnt__PauseSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		return (void*)soap_instantiate__wsnt__PauseSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__ResumeSubscription:
		return (void*)soap_instantiate__wsnt__ResumeSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		return (void*)soap_instantiate__wsnt__ResumeSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__Documentation:
		return (void*)soap_instantiate_wstop__Documentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return (void*)soap_instantiate_wstop__ExtensibleDocumented(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__QueryExpressionType:
		return (void*)soap_instantiate_wstop__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		return (void*)soap_instantiate_wsrfr__ResourceUnknownFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		return (void*)soap_instantiate_wsrfr__ResourceUnavailableFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return (void*)soap_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return (void*)soap_instantiate_wsnt__InvalidFilterFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return (void*)soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return (void*)soap_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return (void*)soap_instantiate_wsnt__TopicNotSupportedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return (void*)soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return (void*)soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return (void*)soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return (void*)soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return (void*)soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return (void*)soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return (void*)soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return (void*)soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return (void*)soap_instantiate_wsnt__UnableToGetMessagesFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return (void*)soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return (void*)soap_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return (void*)soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return (void*)soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return (void*)soap_instantiate_wsnt__PauseFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return (void*)soap_instantiate_wsnt__ResumeFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		return (void*)soap_instantiate__wstop__TopicNamespaceType_Topic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return (void*)soap_instantiate_wstop__TopicNamespaceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicType:
		return (void*)soap_instantiate_wstop__TopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicSetType:
		return (void*)soap_instantiate_wstop__TopicSetType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___tev__PullMessages:
		return (void*)soap_instantiate___tev__PullMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Seek:
		return (void*)soap_instantiate___tev__Seek(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__SetSynchronizationPoint:
		return (void*)soap_instantiate___tev__SetSynchronizationPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Unsubscribe:
		return (void*)soap_instantiate___tev__Unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__GetServiceCapabilities:
		return (void*)soap_instantiate___tev__GetServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__CreatePullPointSubscription:
		return (void*)soap_instantiate___tev__CreatePullPointSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__GetEventProperties:
		return (void*)soap_instantiate___tev__GetEventProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Renew:
		return (void*)soap_instantiate___tev__Renew(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Unsubscribe_:
		return (void*)soap_instantiate___tev__Unsubscribe_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Subscribe:
		return (void*)soap_instantiate___tev__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__GetCurrentMessage:
		return (void*)soap_instantiate___tev__GetCurrentMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Notify:
		return (void*)soap_instantiate___tev__Notify(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__GetMessages:
		return (void*)soap_instantiate___tev__GetMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__DestroyPullPoint:
		return (void*)soap_instantiate___tev__DestroyPullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Notify_:
		return (void*)soap_instantiate___tev__Notify_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__CreatePullPoint:
		return (void*)soap_instantiate___tev__CreatePullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Renew_:
		return (void*)soap_instantiate___tev__Renew_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__Unsubscribe__:
		return (void*)soap_instantiate___tev__Unsubscribe__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__PauseSubscription:
		return (void*)soap_instantiate___tev__PauseSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tev__ResumeSubscription:
		return (void*)soap_instantiate___tev__ResumeSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)soap_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)soap_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)soap_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)soap_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)soap_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)soap_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)soap_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)soap_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token:
		return (void*)soap_instantiate_xsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)soap_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		return (void*)soap_instantiate_wsnt__AbsoluteOrRelativeTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__FullTopicExpression:
		return (void*)soap_instantiate_wstop__FullTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return (void*)soap_instantiate_wstop__ConcreteTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		return (void*)soap_instantiate_wstop__SimpleTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tev__Capabilities:
		return (void*)soap_instantiate__tev__Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfr__ResourceUnknownFault:
		return (void*)soap_instantiate__wsrfr__ResourceUnknownFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfr__ResourceUnavailableFault:
		return (void*)soap_instantiate__wsrfr__ResourceUnavailableFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFault:
		return (void*)soap_instantiate__wsrfbf__BaseFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__TopicExpression:
		return (void*)soap_instantiate__wsnt__TopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__TopicExpressionDialect:
		return (void*)soap_instantiate__wsnt__TopicExpressionDialect(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__ConsumerReference:
		return (void*)soap_instantiate__wsnt__ConsumerReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Filter:
		return (void*)soap_instantiate__wsnt__Filter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__SubscriptionPolicy:
		return (void*)soap_instantiate__wsnt__SubscriptionPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__SubscriptionReference:
		return (void*)soap_instantiate__wsnt__SubscriptionReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__Topic:
		return (void*)soap_instantiate__wsnt__Topic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__ProducerReference:
		return (void*)soap_instantiate__wsnt__ProducerReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__NotificationMessage:
		return (void*)soap_instantiate__wsnt__NotificationMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__ProducerProperties:
		return (void*)soap_instantiate__wsnt__ProducerProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__MessageContent:
		return (void*)soap_instantiate__wsnt__MessageContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFault:
		return (void*)soap_instantiate__wsnt__SubscribeCreationFailedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__InvalidFilterFault:
		return (void*)soap_instantiate__wsnt__InvalidFilterFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFault:
		return (void*)soap_instantiate__wsnt__TopicExpressionDialectUnknownFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFault:
		return (void*)soap_instantiate__wsnt__InvalidTopicExpressionFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__TopicNotSupportedFault:
		return (void*)soap_instantiate__wsnt__TopicNotSupportedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFault:
		return (void*)soap_instantiate__wsnt__MultipleTopicsSpecifiedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFault:
		return (void*)soap_instantiate__wsnt__InvalidProducerPropertiesExpressionFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFault:
		return (void*)soap_instantiate__wsnt__InvalidMessageContentExpressionFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFault:
		return (void*)soap_instantiate__wsnt__UnrecognizedPolicyRequestFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFault:
		return (void*)soap_instantiate__wsnt__UnsupportedPolicyRequestFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFault:
		return (void*)soap_instantiate__wsnt__NotifyMessageNotSupportedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFault:
		return (void*)soap_instantiate__wsnt__UnacceptableInitialTerminationTimeFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFault:
		return (void*)soap_instantiate__wsnt__NoCurrentMessageOnTopicFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnableToGetMessagesFault:
		return (void*)soap_instantiate__wsnt__UnableToGetMessagesFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFault:
		return (void*)soap_instantiate__wsnt__UnableToDestroyPullPointFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFault:
		return (void*)soap_instantiate__wsnt__UnableToCreatePullPointFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFault:
		return (void*)soap_instantiate__wsnt__UnacceptableTerminationTimeFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFault:
		return (void*)soap_instantiate__wsnt__UnableToDestroySubscriptionFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__PauseFailedFault:
		return (void*)soap_instantiate__wsnt__PauseFailedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnt__ResumeFailedFault:
		return (void*)soap_instantiate__wsnt__ResumeFailedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wstop__TopicNamespace:
		return (void*)soap_instantiate__wstop__TopicNamespace(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wstop__TopicSet:
		return (void*)soap_instantiate__wstop__TopicSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wstop__topicNamespaceLocation:
		return (void*)soap_instantiate__wstop__topicNamespaceLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic:
		return (void*)soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description:
		return (void*)soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tev__Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tev__Capabilities*>(p->ptr), tev__Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tev__Capabilities*>(p->ptr), tev__Capabilities);
		break;
	case SOAP_TYPE__tev__GetServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__GetServiceCapabilities*>(p->ptr), _tev__GetServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__GetServiceCapabilities*>(p->ptr), _tev__GetServiceCapabilities);
		break;
	case SOAP_TYPE__tev__GetServiceCapabilitiesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__GetServiceCapabilitiesResponse*>(p->ptr), _tev__GetServiceCapabilitiesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__GetServiceCapabilitiesResponse*>(p->ptr), _tev__GetServiceCapabilitiesResponse);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__CreatePullPointSubscription_SubscriptionPolicy*>(p->ptr), _tev__CreatePullPointSubscription_SubscriptionPolicy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__CreatePullPointSubscription_SubscriptionPolicy*>(p->ptr), _tev__CreatePullPointSubscription_SubscriptionPolicy);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__CreatePullPointSubscription*>(p->ptr), _tev__CreatePullPointSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__CreatePullPointSubscription*>(p->ptr), _tev__CreatePullPointSubscription);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__CreatePullPointSubscriptionResponse*>(p->ptr), _tev__CreatePullPointSubscriptionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__CreatePullPointSubscriptionResponse*>(p->ptr), _tev__CreatePullPointSubscriptionResponse);
		break;
	case SOAP_TYPE__tev__PullMessages:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__PullMessages*>(p->ptr), _tev__PullMessages);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__PullMessages*>(p->ptr), _tev__PullMessages);
		break;
	case SOAP_TYPE__tev__PullMessagesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__PullMessagesResponse*>(p->ptr), _tev__PullMessagesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__PullMessagesResponse*>(p->ptr), _tev__PullMessagesResponse);
		break;
	case SOAP_TYPE__tev__PullMessagesFaultResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__PullMessagesFaultResponse*>(p->ptr), _tev__PullMessagesFaultResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__PullMessagesFaultResponse*>(p->ptr), _tev__PullMessagesFaultResponse);
		break;
	case SOAP_TYPE__tev__Seek:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__Seek*>(p->ptr), _tev__Seek);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__Seek*>(p->ptr), _tev__Seek);
		break;
	case SOAP_TYPE__tev__SeekResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__SeekResponse*>(p->ptr), _tev__SeekResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__SeekResponse*>(p->ptr), _tev__SeekResponse);
		break;
	case SOAP_TYPE__tev__SetSynchronizationPoint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__SetSynchronizationPoint*>(p->ptr), _tev__SetSynchronizationPoint);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__SetSynchronizationPoint*>(p->ptr), _tev__SetSynchronizationPoint);
		break;
	case SOAP_TYPE__tev__SetSynchronizationPointResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__SetSynchronizationPointResponse*>(p->ptr), _tev__SetSynchronizationPointResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__SetSynchronizationPointResponse*>(p->ptr), _tev__SetSynchronizationPointResponse);
		break;
	case SOAP_TYPE__tev__GetEventProperties:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__GetEventProperties*>(p->ptr), _tev__GetEventProperties);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__GetEventProperties*>(p->ptr), _tev__GetEventProperties);
		break;
	case SOAP_TYPE__tev__GetEventPropertiesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tev__GetEventPropertiesResponse*>(p->ptr), _tev__GetEventPropertiesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tev__GetEventPropertiesResponse*>(p->ptr), _tev__GetEventPropertiesResponse);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsrfbf__BaseFaultType_ErrorCode*>(p->ptr), _wsrfbf__BaseFaultType_ErrorCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsrfbf__BaseFaultType_ErrorCode*>(p->ptr), _wsrfbf__BaseFaultType_ErrorCode);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsrfbf__BaseFaultType_Description*>(p->ptr), _wsrfbf__BaseFaultType_Description);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsrfbf__BaseFaultType_Description*>(p->ptr), _wsrfbf__BaseFaultType_Description);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsrfbf__BaseFaultType_FaultCause*>(p->ptr), _wsrfbf__BaseFaultType_FaultCause);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsrfbf__BaseFaultType_FaultCause*>(p->ptr), _wsrfbf__BaseFaultType_FaultCause);
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsrfbf__BaseFaultType*>(p->ptr), wsrfbf__BaseFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsrfbf__BaseFaultType*>(p->ptr), wsrfbf__BaseFaultType);
		break;
	case SOAP_TYPE_wsnt__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__QueryExpressionType*>(p->ptr), wsnt__QueryExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__QueryExpressionType*>(p->ptr), wsnt__QueryExpressionType);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicExpressionType*>(p->ptr), wsnt__TopicExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicExpressionType*>(p->ptr), wsnt__TopicExpressionType);
		break;
	case SOAP_TYPE_wsnt__FilterType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__FilterType*>(p->ptr), wsnt__FilterType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__FilterType*>(p->ptr), wsnt__FilterType);
		break;
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__SubscriptionPolicyType*>(p->ptr), wsnt__SubscriptionPolicyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__SubscriptionPolicyType*>(p->ptr), wsnt__SubscriptionPolicyType);
		break;
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__NotificationMessageHolderType_Message*>(p->ptr), _wsnt__NotificationMessageHolderType_Message);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__NotificationMessageHolderType_Message*>(p->ptr), _wsnt__NotificationMessageHolderType_Message);
		break;
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NotificationMessageHolderType*>(p->ptr), wsnt__NotificationMessageHolderType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NotificationMessageHolderType*>(p->ptr), wsnt__NotificationMessageHolderType);
		break;
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__NotificationProducerRP*>(p->ptr), _wsnt__NotificationProducerRP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__NotificationProducerRP*>(p->ptr), _wsnt__NotificationProducerRP);
		break;
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__SubscriptionManagerRP*>(p->ptr), _wsnt__SubscriptionManagerRP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__SubscriptionManagerRP*>(p->ptr), _wsnt__SubscriptionManagerRP);
		break;
	case SOAP_TYPE__wsnt__Notify:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Notify*>(p->ptr), _wsnt__Notify);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Notify*>(p->ptr), _wsnt__Notify);
		break;
	case SOAP_TYPE__wsnt__UseRaw:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__UseRaw*>(p->ptr), _wsnt__UseRaw);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__UseRaw*>(p->ptr), _wsnt__UseRaw);
		break;
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Subscribe_SubscriptionPolicy*>(p->ptr), _wsnt__Subscribe_SubscriptionPolicy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Subscribe_SubscriptionPolicy*>(p->ptr), _wsnt__Subscribe_SubscriptionPolicy);
		break;
	case SOAP_TYPE__wsnt__Subscribe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Subscribe*>(p->ptr), _wsnt__Subscribe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Subscribe*>(p->ptr), _wsnt__Subscribe);
		break;
	case SOAP_TYPE__wsnt__SubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__SubscribeResponse*>(p->ptr), _wsnt__SubscribeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__SubscribeResponse*>(p->ptr), _wsnt__SubscribeResponse);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__GetCurrentMessage*>(p->ptr), _wsnt__GetCurrentMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__GetCurrentMessage*>(p->ptr), _wsnt__GetCurrentMessage);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__GetCurrentMessageResponse*>(p->ptr), _wsnt__GetCurrentMessageResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__GetCurrentMessageResponse*>(p->ptr), _wsnt__GetCurrentMessageResponse);
		break;
	case SOAP_TYPE__wsnt__GetMessages:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__GetMessages*>(p->ptr), _wsnt__GetMessages);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__GetMessages*>(p->ptr), _wsnt__GetMessages);
		break;
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__GetMessagesResponse*>(p->ptr), _wsnt__GetMessagesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__GetMessagesResponse*>(p->ptr), _wsnt__GetMessagesResponse);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__DestroyPullPoint*>(p->ptr), _wsnt__DestroyPullPoint);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__DestroyPullPoint*>(p->ptr), _wsnt__DestroyPullPoint);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__DestroyPullPointResponse*>(p->ptr), _wsnt__DestroyPullPointResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__DestroyPullPointResponse*>(p->ptr), _wsnt__DestroyPullPointResponse);
		break;
	case SOAP_TYPE__wsnt__CreatePullPoint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__CreatePullPoint*>(p->ptr), _wsnt__CreatePullPoint);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__CreatePullPoint*>(p->ptr), _wsnt__CreatePullPoint);
		break;
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__CreatePullPointResponse*>(p->ptr), _wsnt__CreatePullPointResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__CreatePullPointResponse*>(p->ptr), _wsnt__CreatePullPointResponse);
		break;
	case SOAP_TYPE__wsnt__Renew:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Renew*>(p->ptr), _wsnt__Renew);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Renew*>(p->ptr), _wsnt__Renew);
		break;
	case SOAP_TYPE__wsnt__RenewResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__RenewResponse*>(p->ptr), _wsnt__RenewResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__RenewResponse*>(p->ptr), _wsnt__RenewResponse);
		break;
	case SOAP_TYPE__wsnt__Unsubscribe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__Unsubscribe*>(p->ptr), _wsnt__Unsubscribe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__Unsubscribe*>(p->ptr), _wsnt__Unsubscribe);
		break;
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__UnsubscribeResponse*>(p->ptr), _wsnt__UnsubscribeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__UnsubscribeResponse*>(p->ptr), _wsnt__UnsubscribeResponse);
		break;
	case SOAP_TYPE__wsnt__PauseSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__PauseSubscription*>(p->ptr), _wsnt__PauseSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__PauseSubscription*>(p->ptr), _wsnt__PauseSubscription);
		break;
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__PauseSubscriptionResponse*>(p->ptr), _wsnt__PauseSubscriptionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__PauseSubscriptionResponse*>(p->ptr), _wsnt__PauseSubscriptionResponse);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__ResumeSubscription*>(p->ptr), _wsnt__ResumeSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__ResumeSubscription*>(p->ptr), _wsnt__ResumeSubscription);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wsnt__ResumeSubscriptionResponse*>(p->ptr), _wsnt__ResumeSubscriptionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wsnt__ResumeSubscriptionResponse*>(p->ptr), _wsnt__ResumeSubscriptionResponse);
		break;
	case SOAP_TYPE_wstop__Documentation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__Documentation*>(p->ptr), wstop__Documentation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__Documentation*>(p->ptr), wstop__Documentation);
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__ExtensibleDocumented*>(p->ptr), wstop__ExtensibleDocumented);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__ExtensibleDocumented*>(p->ptr), wstop__ExtensibleDocumented);
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__QueryExpressionType*>(p->ptr), wstop__QueryExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__QueryExpressionType*>(p->ptr), wstop__QueryExpressionType);
		break;
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsrfr__ResourceUnknownFaultType*>(p->ptr), wsrfr__ResourceUnknownFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsrfr__ResourceUnknownFaultType*>(p->ptr), wsrfr__ResourceUnknownFaultType);
		break;
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsrfr__ResourceUnavailableFaultType*>(p->ptr), wsrfr__ResourceUnavailableFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsrfr__ResourceUnavailableFaultType*>(p->ptr), wsrfr__ResourceUnavailableFaultType);
		break;
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__SubscribeCreationFailedFaultType*>(p->ptr), wsnt__SubscribeCreationFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__SubscribeCreationFailedFaultType*>(p->ptr), wsnt__SubscribeCreationFailedFaultType);
		break;
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidFilterFaultType*>(p->ptr), wsnt__InvalidFilterFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidFilterFaultType*>(p->ptr), wsnt__InvalidFilterFaultType);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicExpressionDialectUnknownFaultType*>(p->ptr), wsnt__TopicExpressionDialectUnknownFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicExpressionDialectUnknownFaultType*>(p->ptr), wsnt__TopicExpressionDialectUnknownFaultType);
		break;
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidTopicExpressionFaultType*>(p->ptr), wsnt__InvalidTopicExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidTopicExpressionFaultType*>(p->ptr), wsnt__InvalidTopicExpressionFaultType);
		break;
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicNotSupportedFaultType*>(p->ptr), wsnt__TopicNotSupportedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicNotSupportedFaultType*>(p->ptr), wsnt__TopicNotSupportedFaultType);
		break;
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__MultipleTopicsSpecifiedFaultType*>(p->ptr), wsnt__MultipleTopicsSpecifiedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__MultipleTopicsSpecifiedFaultType*>(p->ptr), wsnt__MultipleTopicsSpecifiedFaultType);
		break;
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidProducerPropertiesExpressionFaultType*>(p->ptr), wsnt__InvalidProducerPropertiesExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidProducerPropertiesExpressionFaultType*>(p->ptr), wsnt__InvalidProducerPropertiesExpressionFaultType);
		break;
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidMessageContentExpressionFaultType*>(p->ptr), wsnt__InvalidMessageContentExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidMessageContentExpressionFaultType*>(p->ptr), wsnt__InvalidMessageContentExpressionFaultType);
		break;
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnrecognizedPolicyRequestFaultType*>(p->ptr), wsnt__UnrecognizedPolicyRequestFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnrecognizedPolicyRequestFaultType*>(p->ptr), wsnt__UnrecognizedPolicyRequestFaultType);
		break;
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnsupportedPolicyRequestFaultType*>(p->ptr), wsnt__UnsupportedPolicyRequestFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnsupportedPolicyRequestFaultType*>(p->ptr), wsnt__UnsupportedPolicyRequestFaultType);
		break;
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NotifyMessageNotSupportedFaultType*>(p->ptr), wsnt__NotifyMessageNotSupportedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NotifyMessageNotSupportedFaultType*>(p->ptr), wsnt__NotifyMessageNotSupportedFaultType);
		break;
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnacceptableInitialTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableInitialTerminationTimeFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnacceptableInitialTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableInitialTerminationTimeFaultType);
		break;
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NoCurrentMessageOnTopicFaultType*>(p->ptr), wsnt__NoCurrentMessageOnTopicFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NoCurrentMessageOnTopicFaultType*>(p->ptr), wsnt__NoCurrentMessageOnTopicFaultType);
		break;
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToGetMessagesFaultType*>(p->ptr), wsnt__UnableToGetMessagesFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToGetMessagesFaultType*>(p->ptr), wsnt__UnableToGetMessagesFaultType);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToDestroyPullPointFaultType*>(p->ptr), wsnt__UnableToDestroyPullPointFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToDestroyPullPointFaultType*>(p->ptr), wsnt__UnableToDestroyPullPointFaultType);
		break;
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToCreatePullPointFaultType*>(p->ptr), wsnt__UnableToCreatePullPointFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToCreatePullPointFaultType*>(p->ptr), wsnt__UnableToCreatePullPointFaultType);
		break;
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnacceptableTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableTerminationTimeFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnacceptableTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableTerminationTimeFaultType);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToDestroySubscriptionFaultType*>(p->ptr), wsnt__UnableToDestroySubscriptionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToDestroySubscriptionFaultType*>(p->ptr), wsnt__UnableToDestroySubscriptionFaultType);
		break;
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__PauseFailedFaultType*>(p->ptr), wsnt__PauseFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__PauseFailedFaultType*>(p->ptr), wsnt__PauseFailedFaultType);
		break;
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__ResumeFailedFaultType*>(p->ptr), wsnt__ResumeFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__ResumeFailedFaultType*>(p->ptr), wsnt__ResumeFailedFaultType);
		break;
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_wstop__TopicNamespaceType_Topic*>(p->ptr), _wstop__TopicNamespaceType_Topic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_wstop__TopicNamespaceType_Topic*>(p->ptr), _wstop__TopicNamespaceType_Topic);
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__TopicNamespaceType*>(p->ptr), wstop__TopicNamespaceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__TopicNamespaceType*>(p->ptr), wstop__TopicNamespaceType);
		break;
	case SOAP_TYPE_wstop__TopicType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__TopicType*>(p->ptr), wstop__TopicType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__TopicType*>(p->ptr), wstop__TopicType);
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__TopicSetType*>(p->ptr), wstop__TopicSetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__TopicSetType*>(p->ptr), wstop__TopicSetType);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
	case SOAP_TYPE___tev__PullMessages:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__PullMessages*>(p->ptr), struct __tev__PullMessages);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__PullMessages*>(p->ptr), struct __tev__PullMessages);
		break;
	case SOAP_TYPE___tev__Seek:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Seek*>(p->ptr), struct __tev__Seek);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Seek*>(p->ptr), struct __tev__Seek);
		break;
	case SOAP_TYPE___tev__SetSynchronizationPoint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__SetSynchronizationPoint*>(p->ptr), struct __tev__SetSynchronizationPoint);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__SetSynchronizationPoint*>(p->ptr), struct __tev__SetSynchronizationPoint);
		break;
	case SOAP_TYPE___tev__Unsubscribe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Unsubscribe*>(p->ptr), struct __tev__Unsubscribe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Unsubscribe*>(p->ptr), struct __tev__Unsubscribe);
		break;
	case SOAP_TYPE___tev__GetServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__GetServiceCapabilities*>(p->ptr), struct __tev__GetServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__GetServiceCapabilities*>(p->ptr), struct __tev__GetServiceCapabilities);
		break;
	case SOAP_TYPE___tev__CreatePullPointSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__CreatePullPointSubscription*>(p->ptr), struct __tev__CreatePullPointSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__CreatePullPointSubscription*>(p->ptr), struct __tev__CreatePullPointSubscription);
		break;
	case SOAP_TYPE___tev__GetEventProperties:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__GetEventProperties*>(p->ptr), struct __tev__GetEventProperties);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__GetEventProperties*>(p->ptr), struct __tev__GetEventProperties);
		break;
	case SOAP_TYPE___tev__Renew:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Renew*>(p->ptr), struct __tev__Renew);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Renew*>(p->ptr), struct __tev__Renew);
		break;
	case SOAP_TYPE___tev__Unsubscribe_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Unsubscribe_*>(p->ptr), struct __tev__Unsubscribe_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Unsubscribe_*>(p->ptr), struct __tev__Unsubscribe_);
		break;
	case SOAP_TYPE___tev__Subscribe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Subscribe*>(p->ptr), struct __tev__Subscribe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Subscribe*>(p->ptr), struct __tev__Subscribe);
		break;
	case SOAP_TYPE___tev__GetCurrentMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__GetCurrentMessage*>(p->ptr), struct __tev__GetCurrentMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__GetCurrentMessage*>(p->ptr), struct __tev__GetCurrentMessage);
		break;
	case SOAP_TYPE___tev__Notify:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Notify*>(p->ptr), struct __tev__Notify);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Notify*>(p->ptr), struct __tev__Notify);
		break;
	case SOAP_TYPE___tev__GetMessages:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__GetMessages*>(p->ptr), struct __tev__GetMessages);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__GetMessages*>(p->ptr), struct __tev__GetMessages);
		break;
	case SOAP_TYPE___tev__DestroyPullPoint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__DestroyPullPoint*>(p->ptr), struct __tev__DestroyPullPoint);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__DestroyPullPoint*>(p->ptr), struct __tev__DestroyPullPoint);
		break;
	case SOAP_TYPE___tev__Notify_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Notify_*>(p->ptr), struct __tev__Notify_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Notify_*>(p->ptr), struct __tev__Notify_);
		break;
	case SOAP_TYPE___tev__CreatePullPoint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__CreatePullPoint*>(p->ptr), struct __tev__CreatePullPoint);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__CreatePullPoint*>(p->ptr), struct __tev__CreatePullPoint);
		break;
	case SOAP_TYPE___tev__Renew_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Renew_*>(p->ptr), struct __tev__Renew_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Renew_*>(p->ptr), struct __tev__Renew_);
		break;
	case SOAP_TYPE___tev__Unsubscribe__:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__Unsubscribe__*>(p->ptr), struct __tev__Unsubscribe__);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__Unsubscribe__*>(p->ptr), struct __tev__Unsubscribe__);
		break;
	case SOAP_TYPE___tev__PauseSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__PauseSubscription*>(p->ptr), struct __tev__PauseSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__PauseSubscription*>(p->ptr), struct __tev__PauseSubscription);
		break;
	case SOAP_TYPE___tev__ResumeSubscription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tev__ResumeSubscription*>(p->ptr), struct __tev__ResumeSubscription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tev__ResumeSubscription*>(p->ptr), struct __tev__ResumeSubscription);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__NCName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__token:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_wstop__FullTopicExpression:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__tev__Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tev__Capabilities*>(p->ptr), tev__Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tev__Capabilities*>(p->ptr), tev__Capabilities);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnknownFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsrfr__ResourceUnknownFaultType*>(p->ptr), wsrfr__ResourceUnknownFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsrfr__ResourceUnknownFaultType*>(p->ptr), wsrfr__ResourceUnknownFaultType);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnavailableFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsrfr__ResourceUnavailableFaultType*>(p->ptr), wsrfr__ResourceUnavailableFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsrfr__ResourceUnavailableFaultType*>(p->ptr), wsrfr__ResourceUnavailableFaultType);
		break;
	case SOAP_TYPE__wsrfbf__BaseFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsrfbf__BaseFaultType*>(p->ptr), wsrfbf__BaseFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsrfbf__BaseFaultType*>(p->ptr), wsrfbf__BaseFaultType);
		break;
	case SOAP_TYPE__wsnt__TopicExpression:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicExpressionType*>(p->ptr), wsnt__TopicExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicExpressionType*>(p->ptr), wsnt__TopicExpressionType);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialect:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__wsnt__ConsumerReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsnt__Filter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__FilterType*>(p->ptr), wsnt__FilterType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__FilterType*>(p->ptr), wsnt__FilterType);
		break;
	case SOAP_TYPE__wsnt__SubscriptionPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__SubscriptionPolicyType*>(p->ptr), wsnt__SubscriptionPolicyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__SubscriptionPolicyType*>(p->ptr), wsnt__SubscriptionPolicyType);
		break;
	case SOAP_TYPE__wsnt__SubscriptionReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsnt__Topic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicExpressionType*>(p->ptr), wsnt__TopicExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicExpressionType*>(p->ptr), wsnt__TopicExpressionType);
		break;
	case SOAP_TYPE__wsnt__ProducerReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsnt__NotificationMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NotificationMessageHolderType*>(p->ptr), wsnt__NotificationMessageHolderType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NotificationMessageHolderType*>(p->ptr), wsnt__NotificationMessageHolderType);
		break;
	case SOAP_TYPE__wsnt__ProducerProperties:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__QueryExpressionType*>(p->ptr), wsnt__QueryExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__QueryExpressionType*>(p->ptr), wsnt__QueryExpressionType);
		break;
	case SOAP_TYPE__wsnt__MessageContent:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__QueryExpressionType*>(p->ptr), wsnt__QueryExpressionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__QueryExpressionType*>(p->ptr), wsnt__QueryExpressionType);
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__SubscribeCreationFailedFaultType*>(p->ptr), wsnt__SubscribeCreationFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__SubscribeCreationFailedFaultType*>(p->ptr), wsnt__SubscribeCreationFailedFaultType);
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidFilterFaultType*>(p->ptr), wsnt__InvalidFilterFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidFilterFaultType*>(p->ptr), wsnt__InvalidFilterFaultType);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicExpressionDialectUnknownFaultType*>(p->ptr), wsnt__TopicExpressionDialectUnknownFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicExpressionDialectUnknownFaultType*>(p->ptr), wsnt__TopicExpressionDialectUnknownFaultType);
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidTopicExpressionFaultType*>(p->ptr), wsnt__InvalidTopicExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidTopicExpressionFaultType*>(p->ptr), wsnt__InvalidTopicExpressionFaultType);
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__TopicNotSupportedFaultType*>(p->ptr), wsnt__TopicNotSupportedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__TopicNotSupportedFaultType*>(p->ptr), wsnt__TopicNotSupportedFaultType);
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__MultipleTopicsSpecifiedFaultType*>(p->ptr), wsnt__MultipleTopicsSpecifiedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__MultipleTopicsSpecifiedFaultType*>(p->ptr), wsnt__MultipleTopicsSpecifiedFaultType);
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidProducerPropertiesExpressionFaultType*>(p->ptr), wsnt__InvalidProducerPropertiesExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidProducerPropertiesExpressionFaultType*>(p->ptr), wsnt__InvalidProducerPropertiesExpressionFaultType);
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__InvalidMessageContentExpressionFaultType*>(p->ptr), wsnt__InvalidMessageContentExpressionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__InvalidMessageContentExpressionFaultType*>(p->ptr), wsnt__InvalidMessageContentExpressionFaultType);
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnrecognizedPolicyRequestFaultType*>(p->ptr), wsnt__UnrecognizedPolicyRequestFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnrecognizedPolicyRequestFaultType*>(p->ptr), wsnt__UnrecognizedPolicyRequestFaultType);
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnsupportedPolicyRequestFaultType*>(p->ptr), wsnt__UnsupportedPolicyRequestFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnsupportedPolicyRequestFaultType*>(p->ptr), wsnt__UnsupportedPolicyRequestFaultType);
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NotifyMessageNotSupportedFaultType*>(p->ptr), wsnt__NotifyMessageNotSupportedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NotifyMessageNotSupportedFaultType*>(p->ptr), wsnt__NotifyMessageNotSupportedFaultType);
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnacceptableInitialTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableInitialTerminationTimeFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnacceptableInitialTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableInitialTerminationTimeFaultType);
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__NoCurrentMessageOnTopicFaultType*>(p->ptr), wsnt__NoCurrentMessageOnTopicFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__NoCurrentMessageOnTopicFaultType*>(p->ptr), wsnt__NoCurrentMessageOnTopicFaultType);
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToGetMessagesFaultType*>(p->ptr), wsnt__UnableToGetMessagesFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToGetMessagesFaultType*>(p->ptr), wsnt__UnableToGetMessagesFaultType);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToDestroyPullPointFaultType*>(p->ptr), wsnt__UnableToDestroyPullPointFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToDestroyPullPointFaultType*>(p->ptr), wsnt__UnableToDestroyPullPointFaultType);
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToCreatePullPointFaultType*>(p->ptr), wsnt__UnableToCreatePullPointFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToCreatePullPointFaultType*>(p->ptr), wsnt__UnableToCreatePullPointFaultType);
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnacceptableTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableTerminationTimeFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnacceptableTerminationTimeFaultType*>(p->ptr), wsnt__UnacceptableTerminationTimeFaultType);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__UnableToDestroySubscriptionFaultType*>(p->ptr), wsnt__UnableToDestroySubscriptionFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__UnableToDestroySubscriptionFaultType*>(p->ptr), wsnt__UnableToDestroySubscriptionFaultType);
		break;
	case SOAP_TYPE__wsnt__PauseFailedFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__PauseFailedFaultType*>(p->ptr), wsnt__PauseFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__PauseFailedFaultType*>(p->ptr), wsnt__PauseFailedFaultType);
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wsnt__ResumeFailedFaultType*>(p->ptr), wsnt__ResumeFailedFaultType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wsnt__ResumeFailedFaultType*>(p->ptr), wsnt__ResumeFailedFaultType);
		break;
	case SOAP_TYPE__wstop__TopicNamespace:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__TopicNamespaceType*>(p->ptr), wstop__TopicNamespaceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__TopicNamespaceType*>(p->ptr), wstop__TopicNamespaceType);
		break;
	case SOAP_TYPE__wstop__TopicSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<wstop__TopicSetType*>(p->ptr), wstop__TopicSetType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<wstop__TopicSetType*>(p->ptr), wstop__TopicSetType);
		break;
	case SOAP_TYPE__wstop__topicNamespaceLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_wstop__TopicNamespaceType_Topic> *>(p->ptr), std::vector<_wstop__TopicNamespaceType_Topic> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_wstop__TopicNamespaceType_Topic> *>(p->ptr), std::vector<_wstop__TopicNamespaceType_Topic> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<wstop__TopicType *> *>(p->ptr), std::vector<wstop__TopicType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<wstop__TopicType *> *>(p->ptr), std::vector<wstop__TopicType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<wsnt__TopicExpressionType *> *>(p->ptr), std::vector<wsnt__TopicExpressionType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<wsnt__TopicExpressionType *> *>(p->ptr), std::vector<wsnt__TopicExpressionType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_wsrfbf__BaseFaultType_Description> *>(p->ptr), std::vector<_wsrfbf__BaseFaultType_Description> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_wsrfbf__BaseFaultType_Description> *>(p->ptr), std::vector<_wsrfbf__BaseFaultType_Description> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<wsnt__NotificationMessageHolderType *> *>(p->ptr), std::vector<wsnt__NotificationMessageHolderType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<wsnt__NotificationMessageHolderType *> *>(p->ptr), std::vector<wsnt__NotificationMessageHolderType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_wsrfr__ResourceUnknownFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__InvalidFilterFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__TopicNotSupportedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__PauseFailedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wsnt__ResumeFailedFaultType: t = SOAP_TYPE_wsrfbf__BaseFaultType; break;
		case SOAP_TYPE_wstop__TopicNamespaceType: t = SOAP_TYPE_wstop__ExtensibleDocumented; break;
		case SOAP_TYPE_wstop__TopicType: t = SOAP_TYPE_wstop__ExtensibleDocumented; break;
		case SOAP_TYPE_wstop__TopicSetType: t = SOAP_TYPE_wstop__ExtensibleDocumented; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic:
		if (t == SOAP_TYPE__wstop__TopicNamespaceType_Topic)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_wstop__TopicNamespaceType_Topic>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_wstop__TopicNamespaceType_Topic> *)p)[index] = *(_wstop__TopicNamespaceType_Topic *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		if (t == SOAP_TYPE_wstop__TopicType || soap_fbase(t, SOAP_TYPE_wstop__TopicType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wstop__TopicType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wstop__TopicType *> *)p)[index] = *(wstop__TopicType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (t == SOAP_TYPE_xsd__QName)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType:
		if (t == SOAP_TYPE_wsnt__TopicExpressionType || soap_fbase(t, SOAP_TYPE_wsnt__TopicExpressionType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsnt__TopicExpressionType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsnt__TopicExpressionType *> *)p)[index] = *(wsnt__TopicExpressionType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description:
		if (t == SOAP_TYPE__wsrfbf__BaseFaultType_Description)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_wsrfbf__BaseFaultType_Description>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_wsrfbf__BaseFaultType_Description> *)p)[index] = *(_wsrfbf__BaseFaultType_Description *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (t == SOAP_TYPE_xsd__anyURI)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType:
		if (t == SOAP_TYPE_wsnt__NotificationMessageHolderType || soap_fbase(t, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsnt__NotificationMessageHolderType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsnt__NotificationMessageHolderType *> *)p)[index] = *(wsnt__NotificationMessageHolderType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct chan__ChannelInstanceType type=%d location=%p object=%p\n", t, p, q));
		*(struct chan__ChannelInstanceType*)p = *(struct chan__ChannelInstanceType*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anyType type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anyType*)p = *(xsd__anyType*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tev__Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tev__Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(tev__Capabilities*)p = *(tev__Capabilities*)q;
		break;
	case SOAP_TYPE__tev__GetServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__GetServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(_tev__GetServiceCapabilities*)p = *(_tev__GetServiceCapabilities*)q;
		break;
	case SOAP_TYPE__tev__GetServiceCapabilitiesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__GetServiceCapabilitiesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tev__GetServiceCapabilitiesResponse*)p = *(_tev__GetServiceCapabilitiesResponse*)q;
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__CreatePullPointSubscription_SubscriptionPolicy type=%d location=%p object=%p\n", t, p, q));
		*(_tev__CreatePullPointSubscription_SubscriptionPolicy*)p = *(_tev__CreatePullPointSubscription_SubscriptionPolicy*)q;
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__CreatePullPointSubscription type=%d location=%p object=%p\n", t, p, q));
		*(_tev__CreatePullPointSubscription*)p = *(_tev__CreatePullPointSubscription*)q;
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscriptionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__CreatePullPointSubscriptionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tev__CreatePullPointSubscriptionResponse*)p = *(_tev__CreatePullPointSubscriptionResponse*)q;
		break;
	case SOAP_TYPE__tev__PullMessages:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__PullMessages type=%d location=%p object=%p\n", t, p, q));
		*(_tev__PullMessages*)p = *(_tev__PullMessages*)q;
		break;
	case SOAP_TYPE__tev__PullMessagesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__PullMessagesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tev__PullMessagesResponse*)p = *(_tev__PullMessagesResponse*)q;
		break;
	case SOAP_TYPE__tev__PullMessagesFaultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__PullMessagesFaultResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tev__PullMessagesFaultResponse*)p = *(_tev__PullMessagesFaultResponse*)q;
		break;
	case SOAP_TYPE__tev__Seek:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__Seek type=%d location=%p object=%p\n", t, p, q));
		*(_tev__Seek*)p = *(_tev__Seek*)q;
		break;
	case SOAP_TYPE__tev__SeekResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__SeekResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tev__SeekResponse*)p = *(_tev__SeekResponse*)q;
		break;
	case SOAP_TYPE__tev__SetSynchronizationPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__SetSynchronizationPoint type=%d location=%p object=%p\n", t, p, q));
		*(_tev__SetSynchronizationPoint*)p = *(_tev__SetSynchronizationPoint*)q;
		break;
	case SOAP_TYPE__tev__SetSynchronizationPointResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__SetSynchronizationPointResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tev__SetSynchronizationPointResponse*)p = *(_tev__SetSynchronizationPointResponse*)q;
		break;
	case SOAP_TYPE__tev__GetEventProperties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__GetEventProperties type=%d location=%p object=%p\n", t, p, q));
		*(_tev__GetEventProperties*)p = *(_tev__GetEventProperties*)q;
		break;
	case SOAP_TYPE__tev__GetEventPropertiesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tev__GetEventPropertiesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tev__GetEventPropertiesResponse*)p = *(_tev__GetEventPropertiesResponse*)q;
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsrfbf__BaseFaultType_ErrorCode type=%d location=%p object=%p\n", t, p, q));
		*(_wsrfbf__BaseFaultType_ErrorCode*)p = *(_wsrfbf__BaseFaultType_ErrorCode*)q;
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsrfbf__BaseFaultType_Description type=%d location=%p object=%p\n", t, p, q));
		*(_wsrfbf__BaseFaultType_Description*)p = *(_wsrfbf__BaseFaultType_Description*)q;
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsrfbf__BaseFaultType_FaultCause type=%d location=%p object=%p\n", t, p, q));
		*(_wsrfbf__BaseFaultType_FaultCause*)p = *(_wsrfbf__BaseFaultType_FaultCause*)q;
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrfbf__BaseFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsrfbf__BaseFaultType*)p = *(wsrfbf__BaseFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__QueryExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__QueryExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__QueryExpressionType*)p = *(wsnt__QueryExpressionType*)q;
		break;
	case SOAP_TYPE_wsnt__TopicExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicExpressionType*)p = *(wsnt__TopicExpressionType*)q;
		break;
	case SOAP_TYPE_wsnt__FilterType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__FilterType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__FilterType*)p = *(wsnt__FilterType*)q;
		break;
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__SubscriptionPolicyType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__SubscriptionPolicyType*)p = *(wsnt__SubscriptionPolicyType*)q;
		break;
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__NotificationMessageHolderType_Message type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__NotificationMessageHolderType_Message*)p = *(_wsnt__NotificationMessageHolderType_Message*)q;
		break;
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NotificationMessageHolderType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NotificationMessageHolderType*)p = *(wsnt__NotificationMessageHolderType*)q;
		break;
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__NotificationProducerRP type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__NotificationProducerRP*)p = *(_wsnt__NotificationProducerRP*)q;
		break;
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__SubscriptionManagerRP type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__SubscriptionManagerRP*)p = *(_wsnt__SubscriptionManagerRP*)q;
		break;
	case SOAP_TYPE__wsnt__Notify:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Notify type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Notify*)p = *(_wsnt__Notify*)q;
		break;
	case SOAP_TYPE__wsnt__UseRaw:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__UseRaw type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__UseRaw*)p = *(_wsnt__UseRaw*)q;
		break;
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Subscribe_SubscriptionPolicy type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Subscribe_SubscriptionPolicy*)p = *(_wsnt__Subscribe_SubscriptionPolicy*)q;
		break;
	case SOAP_TYPE__wsnt__Subscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Subscribe type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Subscribe*)p = *(_wsnt__Subscribe*)q;
		break;
	case SOAP_TYPE__wsnt__SubscribeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__SubscribeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__SubscribeResponse*)p = *(_wsnt__SubscribeResponse*)q;
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__GetCurrentMessage type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__GetCurrentMessage*)p = *(_wsnt__GetCurrentMessage*)q;
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__GetCurrentMessageResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__GetCurrentMessageResponse*)p = *(_wsnt__GetCurrentMessageResponse*)q;
		break;
	case SOAP_TYPE__wsnt__GetMessages:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__GetMessages type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__GetMessages*)p = *(_wsnt__GetMessages*)q;
		break;
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__GetMessagesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__GetMessagesResponse*)p = *(_wsnt__GetMessagesResponse*)q;
		break;
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__DestroyPullPoint type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__DestroyPullPoint*)p = *(_wsnt__DestroyPullPoint*)q;
		break;
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__DestroyPullPointResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__DestroyPullPointResponse*)p = *(_wsnt__DestroyPullPointResponse*)q;
		break;
	case SOAP_TYPE__wsnt__CreatePullPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__CreatePullPoint type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__CreatePullPoint*)p = *(_wsnt__CreatePullPoint*)q;
		break;
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__CreatePullPointResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__CreatePullPointResponse*)p = *(_wsnt__CreatePullPointResponse*)q;
		break;
	case SOAP_TYPE__wsnt__Renew:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Renew type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Renew*)p = *(_wsnt__Renew*)q;
		break;
	case SOAP_TYPE__wsnt__RenewResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__RenewResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__RenewResponse*)p = *(_wsnt__RenewResponse*)q;
		break;
	case SOAP_TYPE__wsnt__Unsubscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__Unsubscribe type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__Unsubscribe*)p = *(_wsnt__Unsubscribe*)q;
		break;
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__UnsubscribeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__UnsubscribeResponse*)p = *(_wsnt__UnsubscribeResponse*)q;
		break;
	case SOAP_TYPE__wsnt__PauseSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__PauseSubscription type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__PauseSubscription*)p = *(_wsnt__PauseSubscription*)q;
		break;
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__PauseSubscriptionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__PauseSubscriptionResponse*)p = *(_wsnt__PauseSubscriptionResponse*)q;
		break;
	case SOAP_TYPE__wsnt__ResumeSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__ResumeSubscription type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__ResumeSubscription*)p = *(_wsnt__ResumeSubscription*)q;
		break;
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wsnt__ResumeSubscriptionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_wsnt__ResumeSubscriptionResponse*)p = *(_wsnt__ResumeSubscriptionResponse*)q;
		break;
	case SOAP_TYPE_wstop__Documentation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__Documentation type=%d location=%p object=%p\n", t, p, q));
		*(wstop__Documentation*)p = *(wstop__Documentation*)q;
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__ExtensibleDocumented type=%d location=%p object=%p\n", t, p, q));
		*(wstop__ExtensibleDocumented*)p = *(wstop__ExtensibleDocumented*)q;
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__QueryExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__QueryExpressionType*)p = *(wstop__QueryExpressionType*)q;
		break;
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrfr__ResourceUnknownFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsrfr__ResourceUnknownFaultType*)p = *(wsrfr__ResourceUnknownFaultType*)q;
		break;
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrfr__ResourceUnavailableFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsrfr__ResourceUnavailableFaultType*)p = *(wsrfr__ResourceUnavailableFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__SubscribeCreationFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__SubscribeCreationFailedFaultType*)p = *(wsnt__SubscribeCreationFailedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidFilterFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidFilterFaultType*)p = *(wsnt__InvalidFilterFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicExpressionDialectUnknownFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicExpressionDialectUnknownFaultType*)p = *(wsnt__TopicExpressionDialectUnknownFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidTopicExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidTopicExpressionFaultType*)p = *(wsnt__InvalidTopicExpressionFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicNotSupportedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicNotSupportedFaultType*)p = *(wsnt__TopicNotSupportedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__MultipleTopicsSpecifiedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__MultipleTopicsSpecifiedFaultType*)p = *(wsnt__MultipleTopicsSpecifiedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidProducerPropertiesExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidProducerPropertiesExpressionFaultType*)p = *(wsnt__InvalidProducerPropertiesExpressionFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidMessageContentExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidMessageContentExpressionFaultType*)p = *(wsnt__InvalidMessageContentExpressionFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnrecognizedPolicyRequestFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnrecognizedPolicyRequestFaultType*)p = *(wsnt__UnrecognizedPolicyRequestFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnsupportedPolicyRequestFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnsupportedPolicyRequestFaultType*)p = *(wsnt__UnsupportedPolicyRequestFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NotifyMessageNotSupportedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NotifyMessageNotSupportedFaultType*)p = *(wsnt__NotifyMessageNotSupportedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnacceptableInitialTerminationTimeFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnacceptableInitialTerminationTimeFaultType*)p = *(wsnt__UnacceptableInitialTerminationTimeFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NoCurrentMessageOnTopicFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NoCurrentMessageOnTopicFaultType*)p = *(wsnt__NoCurrentMessageOnTopicFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToGetMessagesFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToGetMessagesFaultType*)p = *(wsnt__UnableToGetMessagesFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToDestroyPullPointFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToDestroyPullPointFaultType*)p = *(wsnt__UnableToDestroyPullPointFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToCreatePullPointFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToCreatePullPointFaultType*)p = *(wsnt__UnableToCreatePullPointFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnacceptableTerminationTimeFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnacceptableTerminationTimeFaultType*)p = *(wsnt__UnacceptableTerminationTimeFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToDestroySubscriptionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToDestroySubscriptionFaultType*)p = *(wsnt__UnableToDestroySubscriptionFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__PauseFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__PauseFailedFaultType*)p = *(wsnt__PauseFailedFaultType*)q;
		break;
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__ResumeFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__ResumeFailedFaultType*)p = *(wsnt__ResumeFailedFaultType*)q;
		break;
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _wstop__TopicNamespaceType_Topic type=%d location=%p object=%p\n", t, p, q));
		*(_wstop__TopicNamespaceType_Topic*)p = *(_wstop__TopicNamespaceType_Topic*)q;
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__TopicNamespaceType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__TopicNamespaceType*)p = *(wstop__TopicNamespaceType*)q;
		break;
	case SOAP_TYPE_wstop__TopicType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__TopicType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__TopicType*)p = *(wstop__TopicType*)q;
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__TopicSetType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__TopicSetType*)p = *(wstop__TopicSetType*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
	case SOAP_TYPE___tev__PullMessages:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__PullMessages type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__PullMessages*)p = *(struct __tev__PullMessages*)q;
		break;
	case SOAP_TYPE___tev__Seek:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Seek type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Seek*)p = *(struct __tev__Seek*)q;
		break;
	case SOAP_TYPE___tev__SetSynchronizationPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__SetSynchronizationPoint type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__SetSynchronizationPoint*)p = *(struct __tev__SetSynchronizationPoint*)q;
		break;
	case SOAP_TYPE___tev__Unsubscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Unsubscribe type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Unsubscribe*)p = *(struct __tev__Unsubscribe*)q;
		break;
	case SOAP_TYPE___tev__GetServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__GetServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__GetServiceCapabilities*)p = *(struct __tev__GetServiceCapabilities*)q;
		break;
	case SOAP_TYPE___tev__CreatePullPointSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__CreatePullPointSubscription type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__CreatePullPointSubscription*)p = *(struct __tev__CreatePullPointSubscription*)q;
		break;
	case SOAP_TYPE___tev__GetEventProperties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__GetEventProperties type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__GetEventProperties*)p = *(struct __tev__GetEventProperties*)q;
		break;
	case SOAP_TYPE___tev__Renew:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Renew type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Renew*)p = *(struct __tev__Renew*)q;
		break;
	case SOAP_TYPE___tev__Unsubscribe_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Unsubscribe_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Unsubscribe_*)p = *(struct __tev__Unsubscribe_*)q;
		break;
	case SOAP_TYPE___tev__Subscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Subscribe type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Subscribe*)p = *(struct __tev__Subscribe*)q;
		break;
	case SOAP_TYPE___tev__GetCurrentMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__GetCurrentMessage type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__GetCurrentMessage*)p = *(struct __tev__GetCurrentMessage*)q;
		break;
	case SOAP_TYPE___tev__Notify:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Notify type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Notify*)p = *(struct __tev__Notify*)q;
		break;
	case SOAP_TYPE___tev__GetMessages:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__GetMessages type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__GetMessages*)p = *(struct __tev__GetMessages*)q;
		break;
	case SOAP_TYPE___tev__DestroyPullPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__DestroyPullPoint type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__DestroyPullPoint*)p = *(struct __tev__DestroyPullPoint*)q;
		break;
	case SOAP_TYPE___tev__Notify_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Notify_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Notify_*)p = *(struct __tev__Notify_*)q;
		break;
	case SOAP_TYPE___tev__CreatePullPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__CreatePullPoint type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__CreatePullPoint*)p = *(struct __tev__CreatePullPoint*)q;
		break;
	case SOAP_TYPE___tev__Renew_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Renew_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Renew_*)p = *(struct __tev__Renew_*)q;
		break;
	case SOAP_TYPE___tev__Unsubscribe__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__Unsubscribe__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__Unsubscribe__*)p = *(struct __tev__Unsubscribe__*)q;
		break;
	case SOAP_TYPE___tev__PauseSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__PauseSubscription type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__PauseSubscription*)p = *(struct __tev__PauseSubscription*)q;
		break;
	case SOAP_TYPE___tev__ResumeSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tev__ResumeSubscription type=%d location=%p object=%p\n", t, p, q));
		*(struct __tev__ResumeSubscription*)p = *(struct __tev__ResumeSubscription*)q;
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE__wsa5__Metadata:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__From:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_xsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__NCName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__token:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__xml__lang:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_wstop__FullTopicExpression:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__tev__Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tev__Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(tev__Capabilities*)p = *(tev__Capabilities*)q;
		break;
	case SOAP_TYPE__wsrfr__ResourceUnknownFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrfr__ResourceUnknownFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsrfr__ResourceUnknownFaultType*)p = *(wsrfr__ResourceUnknownFaultType*)q;
		break;
	case SOAP_TYPE__wsrfr__ResourceUnavailableFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrfr__ResourceUnavailableFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsrfr__ResourceUnavailableFaultType*)p = *(wsrfr__ResourceUnavailableFaultType*)q;
		break;
	case SOAP_TYPE__wsrfbf__BaseFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrfbf__BaseFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsrfbf__BaseFaultType*)p = *(wsrfbf__BaseFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__TopicExpression:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicExpressionType*)p = *(wsnt__TopicExpressionType*)q;
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialect:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__wsnt__ConsumerReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsnt__Filter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__FilterType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__FilterType*)p = *(wsnt__FilterType*)q;
		break;
	case SOAP_TYPE__wsnt__SubscriptionPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__SubscriptionPolicyType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__SubscriptionPolicyType*)p = *(wsnt__SubscriptionPolicyType*)q;
		break;
	case SOAP_TYPE__wsnt__SubscriptionReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsnt__Topic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicExpressionType*)p = *(wsnt__TopicExpressionType*)q;
		break;
	case SOAP_TYPE__wsnt__ProducerReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsnt__NotificationMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NotificationMessageHolderType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NotificationMessageHolderType*)p = *(wsnt__NotificationMessageHolderType*)q;
		break;
	case SOAP_TYPE__wsnt__ProducerProperties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__QueryExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__QueryExpressionType*)p = *(wsnt__QueryExpressionType*)q;
		break;
	case SOAP_TYPE__wsnt__MessageContent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__QueryExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__QueryExpressionType*)p = *(wsnt__QueryExpressionType*)q;
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__SubscribeCreationFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__SubscribeCreationFailedFaultType*)p = *(wsnt__SubscribeCreationFailedFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidFilterFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidFilterFaultType*)p = *(wsnt__InvalidFilterFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicExpressionDialectUnknownFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicExpressionDialectUnknownFaultType*)p = *(wsnt__TopicExpressionDialectUnknownFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidTopicExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidTopicExpressionFaultType*)p = *(wsnt__InvalidTopicExpressionFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__TopicNotSupportedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__TopicNotSupportedFaultType*)p = *(wsnt__TopicNotSupportedFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__MultipleTopicsSpecifiedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__MultipleTopicsSpecifiedFaultType*)p = *(wsnt__MultipleTopicsSpecifiedFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidProducerPropertiesExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidProducerPropertiesExpressionFaultType*)p = *(wsnt__InvalidProducerPropertiesExpressionFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__InvalidMessageContentExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__InvalidMessageContentExpressionFaultType*)p = *(wsnt__InvalidMessageContentExpressionFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnrecognizedPolicyRequestFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnrecognizedPolicyRequestFaultType*)p = *(wsnt__UnrecognizedPolicyRequestFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnsupportedPolicyRequestFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnsupportedPolicyRequestFaultType*)p = *(wsnt__UnsupportedPolicyRequestFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NotifyMessageNotSupportedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NotifyMessageNotSupportedFaultType*)p = *(wsnt__NotifyMessageNotSupportedFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnacceptableInitialTerminationTimeFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnacceptableInitialTerminationTimeFaultType*)p = *(wsnt__UnacceptableInitialTerminationTimeFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__NoCurrentMessageOnTopicFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__NoCurrentMessageOnTopicFaultType*)p = *(wsnt__NoCurrentMessageOnTopicFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToGetMessagesFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToGetMessagesFaultType*)p = *(wsnt__UnableToGetMessagesFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToDestroyPullPointFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToDestroyPullPointFaultType*)p = *(wsnt__UnableToDestroyPullPointFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToCreatePullPointFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToCreatePullPointFaultType*)p = *(wsnt__UnableToCreatePullPointFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnacceptableTerminationTimeFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnacceptableTerminationTimeFaultType*)p = *(wsnt__UnacceptableTerminationTimeFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__UnableToDestroySubscriptionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__UnableToDestroySubscriptionFaultType*)p = *(wsnt__UnableToDestroySubscriptionFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__PauseFailedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__PauseFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__PauseFailedFaultType*)p = *(wsnt__PauseFailedFaultType*)q;
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsnt__ResumeFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(wsnt__ResumeFailedFaultType*)p = *(wsnt__ResumeFailedFaultType*)q;
		break;
	case SOAP_TYPE__wstop__TopicNamespace:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__TopicNamespaceType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__TopicNamespaceType*)p = *(wstop__TopicNamespaceType*)q;
		break;
	case SOAP_TYPE__wstop__TopicSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wstop__TopicSetType type=%d location=%p object=%p\n", t, p, q));
		*(wstop__TopicSetType*)p = *(wstop__TopicSetType*)q;
		break;
	case SOAP_TYPE__wstop__topicNamespaceLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_xsd__duration(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_xsd__duration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *a = static_cast<enum _wsa5__IsReferenceParameter *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter)));
	for (enum _wsa5__IsReferenceParameter *p = a; p && n--; ++p)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *a = static_cast<enum wsa5__FaultCodesType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType)));
	for (enum wsa5__FaultCodesType *p = a; p && n--; ++p)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *a = static_cast<enum wsa5__RelationshipType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType)));
	for (enum wsa5__RelationshipType *p = a; p && n--; ++p)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wstop__TopicNamespaceType_Topic::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_wstop__TopicNamespaceType_Topic::documentation = NULL;
	this->_wstop__TopicNamespaceType_Topic::__anyAttribute = NULL;
	this->_wstop__TopicNamespaceType_Topic::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->_wstop__TopicNamespaceType_Topic::Topic);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wstop__TopicNamespaceType_Topic::__any);
	soap_default_xsd__NCName(soap, &this->_wstop__TopicNamespaceType_Topic::name);
	this->_wstop__TopicNamespaceType_Topic::messageTypes = NULL;
	this->_wstop__TopicNamespaceType_Topic::final_ = (bool)0;
	this->_wstop__TopicNamespaceType_Topic::parent = NULL;
}

void _wstop__TopicNamespaceType_Topic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &this->_wstop__TopicNamespaceType_Topic::documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &this->_wstop__TopicNamespaceType_Topic::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->_wstop__TopicNamespaceType_Topic::Topic);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wstop__TopicNamespaceType_Topic::__any);
#endif
}

int _wstop__TopicNamespaceType_Topic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wstop__TopicNamespaceType_Topic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	if (((_wstop__TopicNamespaceType_Topic*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wstop__TopicNamespaceType_Topic*)a)->__anyAttribute, 1);
	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((_wstop__TopicNamespaceType_Topic*)a)->name), 1);
	if (((_wstop__TopicNamespaceType_Topic*)a)->messageTypes)
	{	soap_set_attr(soap, "messageTypes", soap_xsd__QName2s(soap, *((_wstop__TopicNamespaceType_Topic*)a)->messageTypes), 1);
	}
	if (((_wstop__TopicNamespaceType_Topic*)a)->final_ != (bool)0)
	{	soap_set_attr(soap, "final", soap_bool2s(soap, ((_wstop__TopicNamespaceType_Topic*)a)->final_), 1);
	}
	if (((_wstop__TopicNamespaceType_Topic*)a)->parent)
	{	soap_set_attr(soap, "parent", soap_wstop__ConcreteTopicExpression2s(soap, *((_wstop__TopicNamespaceType_Topic*)a)->parent), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->_wstop__TopicNamespaceType_Topic::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->_wstop__TopicNamespaceType_Topic::MessagePattern, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", -1, &a->_wstop__TopicNamespaceType_Topic::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wstop__TopicNamespaceType_Topic::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wstop__TopicNamespaceType_Topic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wstop__TopicNamespaceType_Topic(soap, tag, this, type);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wstop__TopicNamespaceType_Topic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wstop__TopicNamespaceType_Topic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wstop__TopicNamespaceType_Topic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wstop__TopicNamespaceType_Topic*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &((_wstop__TopicNamespaceType_Topic*)a)->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(((_wstop__TopicNamespaceType_Topic*)a)->messageTypes = soap_new_xsd__QName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__QName(soap, t, ((_wstop__TopicNamespaceType_Topic*)a)->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((_wstop__TopicNamespaceType_Topic*)a)->final_))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "parent", 5, 0);
		if (t)
		{
			if (!(((_wstop__TopicNamespaceType_Topic*)a)->parent = soap_new_wstop__ConcreteTopicExpression(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2wstop__ConcreteTopicExpression(soap, t, ((_wstop__TopicNamespaceType_Topic*)a)->parent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->_wstop__TopicNamespaceType_Topic::documentation, "wstop:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->_wstop__TopicNamespaceType_Topic::MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", &a->_wstop__TopicNamespaceType_Topic::Topic, "wstop:TopicType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wstop__TopicNamespaceType_Topic::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wstop__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wstop__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wstop__TopicNamespaceType_Topic *p;
	size_t k = sizeof(_wstop__TopicNamespaceType_Topic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wstop__TopicNamespaceType_Topic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wstop__TopicNamespaceType_Topic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wstop__TopicNamespaceType_Topic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wstop__TopicNamespaceType_Topic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wstop__TopicNamespaceType_Topic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wstop__TopicNamespaceType_Topic(soap, tag ? tag : "wstop:TopicNamespaceType-Topic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wstop__TopicNamespaceType_Topic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wstop__TopicNamespaceType_Topic(soap, this, tag, type);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *p, const char *tag, const char *type)
{
	if ((p = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Subscribe_SubscriptionPolicy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Subscribe_SubscriptionPolicy::__any);
}

void _wsnt__Subscribe_SubscriptionPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Subscribe_SubscriptionPolicy::__any);
#endif
}

int _wsnt__Subscribe_SubscriptionPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Subscribe_SubscriptionPolicy::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Subscribe_SubscriptionPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Subscribe_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Subscribe_SubscriptionPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Subscribe_SubscriptionPolicy::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Subscribe_SubscriptionPolicy *p;
	size_t k = sizeof(_wsnt__Subscribe_SubscriptionPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Subscribe_SubscriptionPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Subscribe_SubscriptionPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Subscribe_SubscriptionPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Subscribe_SubscriptionPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Subscribe_SubscriptionPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Subscribe_SubscriptionPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__NotificationMessageHolderType_Message::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_wsnt__NotificationMessageHolderType_Message::__any = NULL;
}

void _wsnt__NotificationMessageHolderType_Message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsnt__NotificationMessageHolderType_Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__NotificationMessageHolderType_Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_wsnt__NotificationMessageHolderType_Message::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__NotificationMessageHolderType_Message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__NotificationMessageHolderType_Message(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__NotificationMessageHolderType_Message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(_wsnt__NotificationMessageHolderType_Message), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__NotificationMessageHolderType_Message)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__NotificationMessageHolderType_Message *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_wsnt__NotificationMessageHolderType_Message::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(_wsnt__NotificationMessageHolderType_Message), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__NotificationMessageHolderType_Message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__NotificationMessageHolderType_Message *p;
	size_t k = sizeof(_wsnt__NotificationMessageHolderType_Message);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__NotificationMessageHolderType_Message);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__NotificationMessageHolderType_Message, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__NotificationMessageHolderType_Message location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__NotificationMessageHolderType_Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, tag ? tag : "wsnt:NotificationMessageHolderType-Message", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__NotificationMessageHolderType_Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__NotificationMessageHolderType_Message(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__wsnt__NotificationMessageHolderType_Message(struct soap *soap, _wsnt__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsrfbf__BaseFaultType_FaultCause::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_wsrfbf__BaseFaultType_FaultCause::__any = NULL;
}

void _wsrfbf__BaseFaultType_FaultCause::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsrfbf__BaseFaultType_FaultCause::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_wsrfbf__BaseFaultType_FaultCause::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsrfbf__BaseFaultType_FaultCause::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsrfbf__BaseFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsrfbf__BaseFaultType_FaultCause *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_wsrfbf__BaseFaultType_FaultCause::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsrfbf__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrfbf__BaseFaultType_FaultCause(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsrfbf__BaseFaultType_FaultCause *p;
	size_t k = sizeof(_wsrfbf__BaseFaultType_FaultCause);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsrfbf__BaseFaultType_FaultCause);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsrfbf__BaseFaultType_FaultCause, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsrfbf__BaseFaultType_FaultCause location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsrfbf__BaseFaultType_FaultCause::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_FaultCause::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_FaultCause(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsrfbf__BaseFaultType_Description::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_wsrfbf__BaseFaultType_Description::__item);
	this->_wsrfbf__BaseFaultType_Description::xml__lang = NULL;
}

void _wsrfbf__BaseFaultType_Description::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->_wsrfbf__BaseFaultType_Description::__item);
#endif
}

int _wsrfbf__BaseFaultType_Description::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_Description(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (((_wsrfbf__BaseFaultType_Description*)a)->xml__lang)
	{	soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, *((_wsrfbf__BaseFaultType_Description*)a)->xml__lang), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->_wsrfbf__BaseFaultType_Description::__item, "");
}

void *_wsrfbf__BaseFaultType_Description::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsrfbf__BaseFaultType_Description(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_wsrfbf__BaseFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsrfbf__BaseFaultType_Description)
		return (_wsrfbf__BaseFaultType_Description *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "xml:lang", 1, 0);
		if (t)
		{
			if (!(((_wsrfbf__BaseFaultType_Description*)a)->xml__lang = soap_new__xml__lang(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_xml__lang(soap, t, ((_wsrfbf__BaseFaultType_Description*)a)->xml__lang))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &a->_wsrfbf__BaseFaultType_Description::__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrfbf__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsrfbf__BaseFaultType_Description *p;
	size_t k = sizeof(_wsrfbf__BaseFaultType_Description);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrfbf__BaseFaultType_Description, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsrfbf__BaseFaultType_Description);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsrfbf__BaseFaultType_Description, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsrfbf__BaseFaultType_Description location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsrfbf__BaseFaultType_Description::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_Description::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_Description(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsrfbf__BaseFaultType_ErrorCode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->_wsrfbf__BaseFaultType_ErrorCode::dialect);
	this->_wsrfbf__BaseFaultType_ErrorCode::__mixed = NULL;
}

void _wsrfbf__BaseFaultType_ErrorCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsrfbf__BaseFaultType_ErrorCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, ((_wsrfbf__BaseFaultType_ErrorCode*)a)->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->_wsrfbf__BaseFaultType_ErrorCode::__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsrfbf__BaseFaultType_ErrorCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsrfbf__BaseFaultType_ErrorCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &((_wsrfbf__BaseFaultType_ErrorCode*)a)->dialect))
		return NULL;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->_wsrfbf__BaseFaultType_ErrorCode::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsrfbf__BaseFaultType_ErrorCode *p;
	size_t k = sizeof(_wsrfbf__BaseFaultType_ErrorCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsrfbf__BaseFaultType_ErrorCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsrfbf__BaseFaultType_ErrorCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsrfbf__BaseFaultType_ErrorCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsrfbf__BaseFaultType_ErrorCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_ErrorCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_ErrorCode(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__CreatePullPointSubscription_SubscriptionPolicy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_tev__CreatePullPointSubscription_SubscriptionPolicy::__any);
}

void _tev__CreatePullPointSubscription_SubscriptionPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_tev__CreatePullPointSubscription_SubscriptionPolicy::__any);
#endif
}

int _tev__CreatePullPointSubscription_SubscriptionPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_tev__CreatePullPointSubscription_SubscriptionPolicy::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__CreatePullPointSubscription_SubscriptionPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(_tev__CreatePullPointSubscription_SubscriptionPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__CreatePullPointSubscription_SubscriptionPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_tev__CreatePullPointSubscription_SubscriptionPolicy::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(_tev__CreatePullPointSubscription_SubscriptionPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__CreatePullPointSubscription_SubscriptionPolicy *p;
	size_t k = sizeof(_tev__CreatePullPointSubscription_SubscriptionPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__CreatePullPointSubscription_SubscriptionPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__CreatePullPointSubscription_SubscriptionPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__CreatePullPointSubscription_SubscriptionPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__CreatePullPointSubscription_SubscriptionPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag ? tag : "tev:CreatePullPointSubscription-SubscriptionPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__CreatePullPointSubscription_SubscriptionPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, _tev__CreatePullPointSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wstop__ConcreteTopicExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_wstop__ConcreteTopicExpression, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wstop__FullTopicExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__FullTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*(\\|([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*)*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__FullTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_wstop__FullTopicExpression, SOAP_TYPE_wstop__FullTopicExpression, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wstop__FullTopicExpression(soap, tag ? tag : "wstop:FullTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__ExtensibleDocumented::soap_default(soap);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wstop__TopicSetType::__any);
}

void wstop__TopicSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wstop__TopicSetType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap *soap, const char *tag, int id, const wstop__TopicSetType *a, const char *type)
{
	if (((wstop__ExtensibleDocumented*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wstop__ExtensibleDocumented*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicSetType), type ? type : "wstop:TopicSetType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wstop__TopicSetType::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__TopicSetType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicSetType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicSetType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicSetType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wstop__ExtensibleDocumented*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_documentation2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wstop__TopicSetType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicSetType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicSetType *p;
	size_t k = sizeof(wstop__TopicSetType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicSetType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicSetType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicSetType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicSetType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicSetType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap *soap, wstop__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__ExtensibleDocumented::soap_default(soap);
	this->wstop__TopicType::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->wstop__TopicType::Topic);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wstop__TopicType::__any);
	soap_default_xsd__NCName(soap, &this->wstop__TopicType::name);
	this->wstop__TopicType::messageTypes = NULL;
	this->wstop__TopicType::final_ = (bool)0;
}

void wstop__TopicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &this->wstop__TopicType::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->wstop__TopicType::Topic);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wstop__TopicType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap *soap, const char *tag, int id, const wstop__TopicType *a, const char *type)
{
	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((wstop__TopicType*)a)->name), 1);
	if (((wstop__TopicType*)a)->messageTypes)
	{	soap_set_attr(soap, "messageTypes", soap_xsd__QName2s(soap, *((wstop__TopicType*)a)->messageTypes), 1);
	}
	if (((wstop__TopicType*)a)->final_ != (bool)0)
	{	soap_set_attr(soap, "final", soap_bool2s(soap, ((wstop__TopicType*)a)->final_), 1);
	}
	if (((wstop__ExtensibleDocumented*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wstop__ExtensibleDocumented*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicType), type ? type : "wstop:TopicType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->wstop__TopicType::MessagePattern, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", -1, &a->wstop__TopicType::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wstop__TopicType::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__TopicType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &((wstop__TopicType*)a)->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(((wstop__TopicType*)a)->messageTypes = soap_new_xsd__QName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__QName(soap, t, ((wstop__TopicType*)a)->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((wstop__TopicType*)a)->final_))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wstop__ExtensibleDocumented*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_documentation2 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->wstop__TopicType::MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", &a->wstop__TopicType::Topic, "wstop:TopicType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wstop__TopicType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicType *p;
	size_t k = sizeof(wstop__TopicType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap *soap, wstop__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicNamespaceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__ExtensibleDocumented::soap_default(soap);
	soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, &this->wstop__TopicNamespaceType::Topic);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wstop__TopicNamespaceType::__any);
	this->wstop__TopicNamespaceType::name = NULL;
	soap_default_xsd__anyURI(soap, &this->wstop__TopicNamespaceType::targetNamespace);
	this->wstop__TopicNamespaceType::final_ = (bool)0;
}

void wstop__TopicNamespaceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, &this->wstop__TopicNamespaceType::Topic);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wstop__TopicNamespaceType::__any);
	this->wstop__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int wstop__TopicNamespaceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicNamespaceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap *soap, const char *tag, int id, const wstop__TopicNamespaceType *a, const char *type)
{
	if (((wstop__TopicNamespaceType*)a)->name)
	{	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, *((wstop__TopicNamespaceType*)a)->name), 1);
	}
	soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((wstop__TopicNamespaceType*)a)->targetNamespace), 1);
	if (((wstop__TopicNamespaceType*)a)->final_ != (bool)0)
	{	soap_set_attr(soap, "final", soap_bool2s(soap, ((wstop__TopicNamespaceType*)a)->final_), 1);
	}
	if (((wstop__ExtensibleDocumented*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wstop__ExtensibleDocumented*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicNamespaceType), type ? type : "wstop:TopicNamespaceType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", -1, &a->wstop__TopicNamespaceType::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wstop__TopicNamespaceType::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicNamespaceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__TopicNamespaceType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap *soap, const char *tag, wstop__TopicNamespaceType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicNamespaceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(wstop__TopicNamespaceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__TopicNamespaceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__TopicNamespaceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "name", 5, 0);
		if (t)
		{
			if (!(((wstop__TopicNamespaceType*)a)->name = soap_new_xsd__NCName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__NCName(soap, t, ((wstop__TopicNamespaceType*)a)->name))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 1), &((wstop__TopicNamespaceType*)a)->targetNamespace))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((wstop__TopicNamespaceType*)a)->final_))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wstop__ExtensibleDocumented*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_documentation2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", &a->wstop__TopicNamespaceType::Topic, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wstop__TopicNamespaceType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(wstop__TopicNamespaceType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicNamespaceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__TopicNamespaceType *p;
	size_t k = sizeof(wstop__TopicNamespaceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__TopicNamespaceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__TopicNamespaceType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__TopicNamespaceType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__TopicNamespaceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__TopicNamespaceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__TopicNamespaceType(soap, tag ? tag : "wstop:TopicNamespaceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicNamespaceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicNamespaceType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap *soap, wstop__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__QueryExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__QueryExpressionType::__any = NULL;
	soap_default_xsd__anyURI(soap, &this->wstop__QueryExpressionType::Dialect);
	this->wstop__QueryExpressionType::__mixed = NULL;
	/* transient soap skipped */
}

void wstop__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wstop__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap *soap, const char *tag, int id, const wstop__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wstop__QueryExpressionType*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__QueryExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->wstop__QueryExpressionType::__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wstop__QueryExpressionType::__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__QueryExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__QueryExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wstop__QueryExpressionType*)a)->Dialect))
		return NULL;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->wstop__QueryExpressionType::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wstop__QueryExpressionType::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__QueryExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__QueryExpressionType *p;
	size_t k = sizeof(wstop__QueryExpressionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__QueryExpressionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__QueryExpressionType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__QueryExpressionType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__QueryExpressionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__ExtensibleDocumented::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__ExtensibleDocumented::documentation = NULL;
	this->wstop__ExtensibleDocumented::__anyAttribute = NULL;
	/* transient soap skipped */
}

void wstop__ExtensibleDocumented::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &this->wstop__ExtensibleDocumented::documentation);
#endif
}

int wstop__ExtensibleDocumented::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__ExtensibleDocumented(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const wstop__ExtensibleDocumented *a, const char *type)
{
	if (((wstop__ExtensibleDocumented*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wstop__ExtensibleDocumented*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__ExtensibleDocumented), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->wstop__ExtensibleDocumented::documentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__ExtensibleDocumented::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__ExtensibleDocumented(soap, tag, this, type);
}

SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, wstop__ExtensibleDocumented *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__ExtensibleDocumented *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(wstop__ExtensibleDocumented), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__ExtensibleDocumented)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__ExtensibleDocumented *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wstop__ExtensibleDocumented*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->wstop__ExtensibleDocumented::documentation, "wstop:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(wstop__ExtensibleDocumented), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__ExtensibleDocumented(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicNamespaceType"))
		return soap_instantiate_wstop__TopicNamespaceType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicType"))
		return soap_instantiate_wstop__TopicType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicSetType"))
		return soap_instantiate_wstop__TopicSetType(soap, n, NULL, NULL, size);
	wstop__ExtensibleDocumented *p;
	size_t k = sizeof(wstop__ExtensibleDocumented);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__ExtensibleDocumented, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__ExtensibleDocumented);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__ExtensibleDocumented, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__ExtensibleDocumented location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__ExtensibleDocumented::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__ExtensibleDocumented(soap, tag ? tag : "wstop:ExtensibleDocumented", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__ExtensibleDocumented::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__ExtensibleDocumented(soap, this, tag, type);
}

SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap *soap, wstop__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__Documentation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->wstop__Documentation::__any);
	this->wstop__Documentation::__mixed = NULL;
	/* transient soap skipped */
}

void wstop__Documentation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wstop__Documentation::__any);
#endif
}

int wstop__Documentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__Documentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap *soap, const char *tag, int id, const wstop__Documentation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__Documentation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wstop__Documentation::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wstop__Documentation::__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__Documentation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__Documentation(soap, tag, this, type);
}

SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__Documentation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wstop__Documentation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wstop__Documentation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wstop__Documentation::__any, ""))
					continue;
			}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wstop__Documentation::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__Documentation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wstop__Documentation *p;
	size_t k = sizeof(wstop__Documentation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wstop__Documentation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wstop__Documentation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wstop__Documentation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wstop__Documentation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wstop__Documentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__Documentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__Documentation(soap, this, tag, type);
}

SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap *soap, wstop__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__ResumeSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__ResumeSubscriptionResponse::__any);
	/* transient soap skipped */
}

void _wsnt__ResumeSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__ResumeSubscriptionResponse::__any);
#endif
}

int _wsnt__ResumeSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__ResumeSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__ResumeSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__ResumeSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__ResumeSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(_wsnt__ResumeSubscriptionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__ResumeSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__ResumeSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__ResumeSubscriptionResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(_wsnt__ResumeSubscriptionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__ResumeSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__ResumeSubscriptionResponse *p;
	size_t k = sizeof(_wsnt__ResumeSubscriptionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__ResumeSubscriptionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__ResumeSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__ResumeSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__ResumeSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__ResumeSubscriptionResponse(soap, tag ? tag : "wsnt:ResumeSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__ResumeSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__ResumeSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__ResumeSubscriptionResponse(struct soap *soap, _wsnt__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__ResumeSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__ResumeSubscription::__any);
	/* transient soap skipped */
}

void _wsnt__ResumeSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__ResumeSubscription::__any);
#endif
}

int _wsnt__ResumeSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__ResumeSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, const _wsnt__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__ResumeSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__ResumeSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__ResumeSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscription * SOAP_FMAC4 soap_in__wsnt__ResumeSubscription(struct soap *soap, const char *tag, _wsnt__ResumeSubscription *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__ResumeSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(_wsnt__ResumeSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__ResumeSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__ResumeSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__ResumeSubscription::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscription, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(_wsnt__ResumeSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__ResumeSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__ResumeSubscription *p;
	size_t k = sizeof(_wsnt__ResumeSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__ResumeSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__ResumeSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__ResumeSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__ResumeSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__ResumeSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__ResumeSubscription(soap, tag ? tag : "wsnt:ResumeSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__ResumeSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__ResumeSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__ResumeSubscription * SOAP_FMAC4 soap_get__wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__PauseSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__PauseSubscriptionResponse::__any);
	/* transient soap skipped */
}

void _wsnt__PauseSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__PauseSubscriptionResponse::__any);
#endif
}

int _wsnt__PauseSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__PauseSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__PauseSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__PauseSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__PauseSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__PauseSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(_wsnt__PauseSubscriptionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__PauseSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__PauseSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__PauseSubscriptionResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscriptionResponse, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(_wsnt__PauseSubscriptionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__PauseSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__PauseSubscriptionResponse *p;
	size_t k = sizeof(_wsnt__PauseSubscriptionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__PauseSubscriptionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__PauseSubscriptionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__PauseSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__PauseSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__PauseSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__PauseSubscriptionResponse(soap, tag ? tag : "wsnt:PauseSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__PauseSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__PauseSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__PauseSubscriptionResponse(struct soap *soap, _wsnt__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__PauseSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__PauseSubscription::__any);
	/* transient soap skipped */
}

void _wsnt__PauseSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__PauseSubscription::__any);
#endif
}

int _wsnt__PauseSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__PauseSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, const _wsnt__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__PauseSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__PauseSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__PauseSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__PauseSubscription * SOAP_FMAC4 soap_in__wsnt__PauseSubscription(struct soap *soap, const char *tag, _wsnt__PauseSubscription *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__PauseSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(_wsnt__PauseSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__PauseSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__PauseSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__PauseSubscription::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscription, SOAP_TYPE__wsnt__PauseSubscription, sizeof(_wsnt__PauseSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__PauseSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__PauseSubscription *p;
	size_t k = sizeof(_wsnt__PauseSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__PauseSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__PauseSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__PauseSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__PauseSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__PauseSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__PauseSubscription(soap, tag ? tag : "wsnt:PauseSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__PauseSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__PauseSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__PauseSubscription * SOAP_FMAC4 soap_get__wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__UnsubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__UnsubscribeResponse::__any);
	/* transient soap skipped */
}

void _wsnt__UnsubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__UnsubscribeResponse::__any);
#endif
}

int _wsnt__UnsubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__UnsubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsubscribeResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__UnsubscribeResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__UnsubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__UnsubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__UnsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(_wsnt__UnsubscribeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__UnsubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__UnsubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__UnsubscribeResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsubscribeResponse, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(_wsnt__UnsubscribeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__UnsubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__UnsubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__UnsubscribeResponse *p;
	size_t k = sizeof(_wsnt__UnsubscribeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__UnsubscribeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__UnsubscribeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__UnsubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__UnsubscribeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__UnsubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__UnsubscribeResponse(soap, tag ? tag : "wsnt:UnsubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__UnsubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__UnsubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnt__UnsubscribeResponse(struct soap *soap, _wsnt__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Unsubscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Unsubscribe::__any);
	/* transient soap skipped */
}

void _wsnt__Unsubscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Unsubscribe::__any);
#endif
}

int _wsnt__Unsubscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Unsubscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, const _wsnt__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Unsubscribe), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Unsubscribe::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Unsubscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__Unsubscribe(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Unsubscribe * SOAP_FMAC4 soap_in__wsnt__Unsubscribe(struct soap *soap, const char *tag, _wsnt__Unsubscribe *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Unsubscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(_wsnt__Unsubscribe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Unsubscribe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Unsubscribe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Unsubscribe::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Unsubscribe, SOAP_TYPE__wsnt__Unsubscribe, sizeof(_wsnt__Unsubscribe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnt__Unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Unsubscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Unsubscribe *p;
	size_t k = sizeof(_wsnt__Unsubscribe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Unsubscribe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Unsubscribe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Unsubscribe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Unsubscribe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Unsubscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Unsubscribe(soap, tag ? tag : "wsnt:Unsubscribe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Unsubscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Unsubscribe(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Unsubscribe * SOAP_FMAC4 soap_get__wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__RenewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->_wsnt__RenewResponse::TerminationTime);
	this->_wsnt__RenewResponse::CurrentTime = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__RenewResponse::__any);
	/* transient soap skipped */
}

void _wsnt__RenewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__RenewResponse::TerminationTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->_wsnt__RenewResponse::CurrentTime);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__RenewResponse::__any);
#endif
}

int _wsnt__RenewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__RenewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__RenewResponse(struct soap *soap, const char *tag, int id, const _wsnt__RenewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__RenewResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:TerminationTime");
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->_wsnt__RenewResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->_wsnt__RenewResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__RenewResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__RenewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__RenewResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__RenewResponse * SOAP_FMAC4 soap_in__wsnt__RenewResponse(struct soap *soap, const char *tag, _wsnt__RenewResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__RenewResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__RenewResponse, sizeof(_wsnt__RenewResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__RenewResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__RenewResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TerminationTime1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->_wsnt__RenewResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->_wsnt__RenewResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__RenewResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "wsnt:TerminationTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__RenewResponse, SOAP_TYPE__wsnt__RenewResponse, sizeof(_wsnt__RenewResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnt__RenewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__RenewResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__RenewResponse *p;
	size_t k = sizeof(_wsnt__RenewResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__RenewResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__RenewResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__RenewResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__RenewResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__RenewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__RenewResponse(soap, tag ? tag : "wsnt:RenewResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__RenewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__RenewResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__RenewResponse * SOAP_FMAC4 soap_get__wsnt__RenewResponse(struct soap *soap, _wsnt__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Renew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__Renew::TerminationTime = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Renew::__any);
	/* transient soap skipped */
}

void _wsnt__Renew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, &this->_wsnt__Renew::TerminationTime);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Renew::__any);
#endif
}

int _wsnt__Renew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Renew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Renew(struct soap *soap, const char *tag, int id, const _wsnt__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Renew), type))
		return soap->error;
	if (!a->_wsnt__Renew::TerminationTime)
	{	if (soap_element_nil(soap, "wsnt:TerminationTime"))
			return soap->error;
	}
	else
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", -1, &a->_wsnt__Renew::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Renew::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Renew::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__Renew(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Renew * SOAP_FMAC4 soap_in__wsnt__Renew(struct soap *soap, const char *tag, _wsnt__Renew *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Renew *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Renew, sizeof(_wsnt__Renew), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Renew)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Renew *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", &a->_wsnt__Renew::TerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Renew::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Renew, SOAP_TYPE__wsnt__Renew, sizeof(_wsnt__Renew), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 soap_instantiate__wsnt__Renew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Renew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Renew *p;
	size_t k = sizeof(_wsnt__Renew);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Renew, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Renew);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Renew, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Renew location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Renew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Renew(soap, tag ? tag : "wsnt:Renew", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Renew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Renew(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Renew * SOAP_FMAC4 soap_get__wsnt__Renew(struct soap *soap, _wsnt__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__CreatePullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__CreatePullPointResponse::PullPoint);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__CreatePullPointResponse::__any);
	this->_wsnt__CreatePullPointResponse::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _wsnt__CreatePullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__CreatePullPointResponse::PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__CreatePullPointResponse::PullPoint);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__CreatePullPointResponse::__any);
#endif
}

int _wsnt__CreatePullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__CreatePullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const _wsnt__CreatePullPointResponse *a, const char *type)
{
	if (((_wsnt__CreatePullPointResponse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__CreatePullPointResponse*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPointResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:PullPoint");
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", -1, &a->_wsnt__CreatePullPointResponse::PullPoint, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__CreatePullPointResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__CreatePullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__CreatePullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, _wsnt__CreatePullPointResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__CreatePullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(_wsnt__CreatePullPointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__CreatePullPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__CreatePullPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__CreatePullPointResponse*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_PullPoint1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", &a->_wsnt__CreatePullPointResponse::PullPoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__CreatePullPointResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "wsnt:PullPoint");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPointResponse, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(_wsnt__CreatePullPointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__CreatePullPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__CreatePullPointResponse *p;
	size_t k = sizeof(_wsnt__CreatePullPointResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__CreatePullPointResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__CreatePullPointResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__CreatePullPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__CreatePullPointResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__CreatePullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__CreatePullPointResponse(soap, tag ? tag : "wsnt:CreatePullPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__CreatePullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__CreatePullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnt__CreatePullPointResponse(struct soap *soap, _wsnt__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__CreatePullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__CreatePullPoint::__any);
	this->_wsnt__CreatePullPoint::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _wsnt__CreatePullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__CreatePullPoint::__any);
#endif
}

int _wsnt__CreatePullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__CreatePullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, const _wsnt__CreatePullPoint *a, const char *type)
{
	if (((_wsnt__CreatePullPoint*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__CreatePullPoint*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__CreatePullPoint::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__CreatePullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__CreatePullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__CreatePullPoint * SOAP_FMAC4 soap_in__wsnt__CreatePullPoint(struct soap *soap, const char *tag, _wsnt__CreatePullPoint *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__CreatePullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(_wsnt__CreatePullPoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__CreatePullPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__CreatePullPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__CreatePullPoint*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__CreatePullPoint::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPoint, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(_wsnt__CreatePullPoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__CreatePullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__CreatePullPoint *p;
	size_t k = sizeof(_wsnt__CreatePullPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__CreatePullPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__CreatePullPoint);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__CreatePullPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__CreatePullPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__CreatePullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__CreatePullPoint(soap, tag ? tag : "wsnt:CreatePullPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__CreatePullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__CreatePullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__CreatePullPoint * SOAP_FMAC4 soap_get__wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__DestroyPullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__DestroyPullPointResponse::__any);
	this->_wsnt__DestroyPullPointResponse::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _wsnt__DestroyPullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__DestroyPullPointResponse::__any);
#endif
}

int _wsnt__DestroyPullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__DestroyPullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const _wsnt__DestroyPullPointResponse *a, const char *type)
{
	if (((_wsnt__DestroyPullPointResponse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__DestroyPullPointResponse*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__DestroyPullPointResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__DestroyPullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__DestroyPullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, _wsnt__DestroyPullPointResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__DestroyPullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(_wsnt__DestroyPullPointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__DestroyPullPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__DestroyPullPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__DestroyPullPointResponse*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__DestroyPullPointResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPointResponse, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(_wsnt__DestroyPullPointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__DestroyPullPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__DestroyPullPointResponse *p;
	size_t k = sizeof(_wsnt__DestroyPullPointResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__DestroyPullPointResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__DestroyPullPointResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__DestroyPullPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__DestroyPullPointResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__DestroyPullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__DestroyPullPointResponse(soap, tag ? tag : "wsnt:DestroyPullPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__DestroyPullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__DestroyPullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnt__DestroyPullPointResponse(struct soap *soap, _wsnt__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__DestroyPullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__DestroyPullPoint::__any);
	this->_wsnt__DestroyPullPoint::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _wsnt__DestroyPullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__DestroyPullPoint::__any);
#endif
}

int _wsnt__DestroyPullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__DestroyPullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, const _wsnt__DestroyPullPoint *a, const char *type)
{
	if (((_wsnt__DestroyPullPoint*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__DestroyPullPoint*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__DestroyPullPoint::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__DestroyPullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__DestroyPullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, _wsnt__DestroyPullPoint *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__DestroyPullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(_wsnt__DestroyPullPoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__DestroyPullPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__DestroyPullPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__DestroyPullPoint*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__DestroyPullPoint::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPoint, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(_wsnt__DestroyPullPoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__DestroyPullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__DestroyPullPoint *p;
	size_t k = sizeof(_wsnt__DestroyPullPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__DestroyPullPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__DestroyPullPoint);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__DestroyPullPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__DestroyPullPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__DestroyPullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__DestroyPullPoint(soap, tag ? tag : "wsnt:DestroyPullPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__DestroyPullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__DestroyPullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__GetMessagesResponse::NotificationMessage);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetMessagesResponse::__any);
	this->_wsnt__GetMessagesResponse::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _wsnt__GetMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__GetMessagesResponse::NotificationMessage);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetMessagesResponse::__any);
#endif
}

int _wsnt__GetMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, const _wsnt__GetMessagesResponse *a, const char *type)
{
	if (((_wsnt__GetMessagesResponse*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__GetMessagesResponse*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:NotificationMessage");
	if (soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->_wsnt__GetMessagesResponse::NotificationMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__GetMessagesResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__GetMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, _wsnt__GetMessagesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(_wsnt__GetMessagesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetMessagesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetMessagesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__GetMessagesResponse*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->_wsnt__GetMessagesResponse::NotificationMessage, "wsnt:NotificationMessageHolderType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__GetMessagesResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "wsnt:NotificationMessage");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessagesResponse, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(_wsnt__GetMessagesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__GetMessagesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetMessagesResponse *p;
	size_t k = sizeof(_wsnt__GetMessagesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetMessagesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetMessagesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetMessagesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetMessagesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetMessagesResponse(soap, tag ? tag : "wsnt:GetMessagesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnt__GetMessagesResponse(struct soap *soap, _wsnt__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetMessages::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__GetMessages::MaximumNumber = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetMessages::__any);
	this->_wsnt__GetMessages::__anyAttribute = NULL;
	/* transient soap skipped */
}

void _wsnt__GetMessages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->_wsnt__GetMessages::MaximumNumber);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetMessages::__any);
#endif
}

int _wsnt__GetMessages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetMessages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessages(struct soap *soap, const char *tag, int id, const _wsnt__GetMessages *a, const char *type)
{
	if (((_wsnt__GetMessages*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_wsnt__GetMessages*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessages), type))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", -1, &a->_wsnt__GetMessages::MaximumNumber, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__GetMessages::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetMessages::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__GetMessages(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetMessages * SOAP_FMAC4 soap_in__wsnt__GetMessages(struct soap *soap, const char *tag, _wsnt__GetMessages *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessages, sizeof(_wsnt__GetMessages), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetMessages)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetMessages *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((_wsnt__GetMessages*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_MaximumNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", &a->_wsnt__GetMessages::MaximumNumber, "xsd:nonNegativeInteger"))
				{	soap_flag_MaximumNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__GetMessages::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessages, SOAP_TYPE__wsnt__GetMessages, sizeof(_wsnt__GetMessages), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 soap_instantiate__wsnt__GetMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__GetMessages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetMessages *p;
	size_t k = sizeof(_wsnt__GetMessages);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetMessages, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetMessages);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetMessages, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetMessages location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetMessages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetMessages(soap, tag ? tag : "wsnt:GetMessages", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetMessages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetMessages(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetMessages * SOAP_FMAC4 soap_get__wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetCurrentMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetCurrentMessageResponse::__any);
	/* transient soap skipped */
}

void _wsnt__GetCurrentMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetCurrentMessageResponse::__any);
#endif
}

int _wsnt__GetCurrentMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetCurrentMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse), type))
		return soap->error;
	soap_element_result(soap, "-any");
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__GetCurrentMessageResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetCurrentMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__GetCurrentMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetCurrentMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(_wsnt__GetCurrentMessageResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetCurrentMessageResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetCurrentMessageResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__GetCurrentMessageResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessageResponse, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(_wsnt__GetCurrentMessageResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__GetCurrentMessageResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetCurrentMessageResponse *p;
	size_t k = sizeof(_wsnt__GetCurrentMessageResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetCurrentMessageResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetCurrentMessageResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetCurrentMessageResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetCurrentMessageResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetCurrentMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetCurrentMessageResponse(soap, tag ? tag : "wsnt:GetCurrentMessageResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetCurrentMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetCurrentMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessageResponse(struct soap *soap, _wsnt__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__GetCurrentMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnt__GetCurrentMessage::Topic = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetCurrentMessage::__any);
	/* transient soap skipped */
}

void _wsnt__GetCurrentMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &this->_wsnt__GetCurrentMessage::Topic);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__GetCurrentMessage::__any);
#endif
}

int _wsnt__GetCurrentMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__GetCurrentMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, const _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessage), type))
		return soap->error;
	if (!a->_wsnt__GetCurrentMessage::Topic)
	{	if (soap_element_empty(soap, "wsnt:Topic"))
			return soap->error;
	}
	else
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->_wsnt__GetCurrentMessage::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__GetCurrentMessage::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__GetCurrentMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__GetCurrentMessage(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__GetCurrentMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(_wsnt__GetCurrentMessage), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__GetCurrentMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__GetCurrentMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Topic1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->_wsnt__GetCurrentMessage::Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__GetCurrentMessage::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_wsnt__GetCurrentMessage::Topic))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessage, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(_wsnt__GetCurrentMessage), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__GetCurrentMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__GetCurrentMessage *p;
	size_t k = sizeof(_wsnt__GetCurrentMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__GetCurrentMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__GetCurrentMessage);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__GetCurrentMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__GetCurrentMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__GetCurrentMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__GetCurrentMessage(soap, tag ? tag : "wsnt:GetCurrentMessage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__GetCurrentMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__GetCurrentMessage(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__SubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference);
	this->_wsnt__SubscribeResponse::CurrentTime = NULL;
	this->_wsnt__SubscribeResponse::TerminationTime = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__SubscribeResponse::__any);
	/* transient soap skipped */
}

void _wsnt__SubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscribeResponse::SubscriptionReference);
	soap_serialize_PointerTodateTime(soap, &this->_wsnt__SubscribeResponse::CurrentTime);
	soap_serialize_PointerTodateTime(soap, &this->_wsnt__SubscribeResponse::TerminationTime);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__SubscribeResponse::__any);
#endif
}

int _wsnt__SubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__SubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, const _wsnt__SubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->_wsnt__SubscribeResponse::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->_wsnt__SubscribeResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:TerminationTime", -1, &a->_wsnt__SubscribeResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__SubscribeResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__SubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__SubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__SubscribeResponse * SOAP_FMAC4 soap_in__wsnt__SubscribeResponse(struct soap *soap, const char *tag, _wsnt__SubscribeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__SubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(_wsnt__SubscribeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__SubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__SubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->_wsnt__SubscribeResponse::SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->_wsnt__SubscribeResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:TerminationTime", &a->_wsnt__SubscribeResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__SubscribeResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "wsnt:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeResponse, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(_wsnt__SubscribeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__SubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__SubscribeResponse *p;
	size_t k = sizeof(_wsnt__SubscribeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__SubscribeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__SubscribeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__SubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__SubscribeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__SubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__SubscribeResponse(soap, tag ? tag : "wsnt:SubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__SubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__SubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__SubscribeResponse * SOAP_FMAC4 soap_get__wsnt__SubscribeResponse(struct soap *soap, _wsnt__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Subscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__Subscribe::ConsumerReference);
	this->_wsnt__Subscribe::Filter = NULL;
	this->_wsnt__Subscribe::InitialTerminationTime = NULL;
	this->_wsnt__Subscribe::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Subscribe::__any);
	/* transient soap skipped */
}

void _wsnt__Subscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__Subscribe::ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__Subscribe::ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &this->_wsnt__Subscribe::Filter);
	soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, &this->_wsnt__Subscribe::InitialTerminationTime);
	soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, &this->_wsnt__Subscribe::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Subscribe::__any);
#endif
}

int _wsnt__Subscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe(struct soap *soap, const char *tag, int id, const _wsnt__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->_wsnt__Subscribe::ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->_wsnt__Subscribe::Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", -1, &a->_wsnt__Subscribe::InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", -1, &a->_wsnt__Subscribe::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Subscribe::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Subscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__Subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Subscribe * SOAP_FMAC4 soap_in__wsnt__Subscribe(struct soap *soap, const char *tag, _wsnt__Subscribe *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Subscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe, sizeof(_wsnt__Subscribe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Subscribe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Subscribe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_InitialTerminationTime1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->_wsnt__Subscribe::ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->_wsnt__Subscribe::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", &a->_wsnt__Subscribe::InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", &a->_wsnt__Subscribe::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Subscribe::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe, SOAP_TYPE__wsnt__Subscribe, sizeof(_wsnt__Subscribe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Subscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Subscribe *p;
	size_t k = sizeof(_wsnt__Subscribe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Subscribe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Subscribe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Subscribe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Subscribe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Subscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Subscribe(soap, tag ? tag : "wsnt:Subscribe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Subscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Subscribe * SOAP_FMAC4 soap_get__wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__UseRaw::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _wsnt__UseRaw::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _wsnt__UseRaw::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__UseRaw(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UseRaw(struct soap *soap, const char *tag, int id, const _wsnt__UseRaw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__UseRaw::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__UseRaw(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__UseRaw * SOAP_FMAC4 soap_in__wsnt__UseRaw(struct soap *soap, const char *tag, _wsnt__UseRaw *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__UseRaw *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UseRaw, sizeof(_wsnt__UseRaw), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__UseRaw)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__UseRaw *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UseRaw, SOAP_TYPE__wsnt__UseRaw, sizeof(_wsnt__UseRaw), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 soap_instantiate__wsnt__UseRaw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__UseRaw(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__UseRaw *p;
	size_t k = sizeof(_wsnt__UseRaw);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__UseRaw, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__UseRaw);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__UseRaw, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__UseRaw location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__UseRaw::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__UseRaw(soap, tag ? tag : "wsnt:UseRaw", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__UseRaw::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__UseRaw(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__UseRaw * SOAP_FMAC4 soap_get__wsnt__UseRaw(struct soap *soap, _wsnt__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__Notify::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__Notify::NotificationMessage);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_wsnt__Notify::__any);
	/* transient soap skipped */
}

void _wsnt__Notify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_wsnt__Notify::NotificationMessage);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_wsnt__Notify::__any);
#endif
}

int _wsnt__Notify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__Notify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Notify(struct soap *soap, const char *tag, int id, const _wsnt__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Notify), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->_wsnt__Notify::NotificationMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_wsnt__Notify::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__Notify::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__Notify(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__Notify * SOAP_FMAC4 soap_in__wsnt__Notify(struct soap *soap, const char *tag, _wsnt__Notify *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__Notify *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Notify, sizeof(_wsnt__Notify), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__Notify)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__Notify *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->_wsnt__Notify::NotificationMessage, "wsnt:NotificationMessageHolderType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_wsnt__Notify::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_wsnt__Notify::NotificationMessage.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Notify, SOAP_TYPE__wsnt__Notify, sizeof(_wsnt__Notify), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 soap_instantiate__wsnt__Notify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__Notify(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__Notify *p;
	size_t k = sizeof(_wsnt__Notify);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__Notify, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__Notify);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__Notify, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__Notify location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__Notify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__Notify(soap, tag ? tag : "wsnt:Notify", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__Notify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__Notify(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__Notify * SOAP_FMAC4 soap_get__wsnt__Notify(struct soap *soap, _wsnt__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__SubscriptionManagerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference);
	this->_wsnt__SubscriptionManagerRP::Filter = NULL;
	this->_wsnt__SubscriptionManagerRP::SubscriptionPolicy = NULL;
	this->_wsnt__SubscriptionManagerRP::CreationTime = NULL;
	/* transient soap skipped */
}

void _wsnt__SubscriptionManagerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnt__SubscriptionManagerRP::ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &this->_wsnt__SubscriptionManagerRP::Filter);
	soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, &this->_wsnt__SubscriptionManagerRP::SubscriptionPolicy);
	soap_serialize_PointerTodateTime(soap, &this->_wsnt__SubscriptionManagerRP::CreationTime);
#endif
}

int _wsnt__SubscriptionManagerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__SubscriptionManagerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->_wsnt__SubscriptionManagerRP::ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->_wsnt__SubscriptionManagerRP::Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", -1, &a->_wsnt__SubscriptionManagerRP::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CreationTime", -1, &a->_wsnt__SubscriptionManagerRP::CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__SubscriptionManagerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__SubscriptionManagerRP(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__SubscriptionManagerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(_wsnt__SubscriptionManagerRP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__SubscriptionManagerRP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__SubscriptionManagerRP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	size_t soap_flag_CreationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->_wsnt__SubscriptionManagerRP::ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->_wsnt__SubscriptionManagerRP::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", &a->_wsnt__SubscriptionManagerRP::SubscriptionPolicy, "wsnt:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap_flag_CreationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CreationTime", &a->_wsnt__SubscriptionManagerRP::CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_wsnt__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscriptionManagerRP, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(_wsnt__SubscriptionManagerRP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnt__SubscriptionManagerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__SubscriptionManagerRP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__SubscriptionManagerRP *p;
	size_t k = sizeof(_wsnt__SubscriptionManagerRP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__SubscriptionManagerRP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__SubscriptionManagerRP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__SubscriptionManagerRP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__SubscriptionManagerRP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__SubscriptionManagerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__SubscriptionManagerRP(soap, tag ? tag : "wsnt:SubscriptionManagerRP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__SubscriptionManagerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__SubscriptionManagerRP(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnt__SubscriptionManagerRP(struct soap *soap, _wsnt__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wsnt__NotificationProducerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, &this->_wsnt__NotificationProducerRP::TopicExpression);
	this->_wsnt__NotificationProducerRP::FixedTopicSet = NULL;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_wsnt__NotificationProducerRP::TopicExpressionDialect);
	this->_wsnt__NotificationProducerRP::wstop__TopicSet = NULL;
	/* transient soap skipped */
}

void _wsnt__NotificationProducerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, &this->_wsnt__NotificationProducerRP::TopicExpression);
	soap_serialize_PointerTobool(soap, &this->_wsnt__NotificationProducerRP::FixedTopicSet);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_wsnt__NotificationProducerRP::TopicExpressionDialect);
	soap_serialize_PointerTowstop__TopicSetType(soap, &this->_wsnt__NotificationProducerRP::wstop__TopicSet);
#endif
}

int _wsnt__NotificationProducerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnt__NotificationProducerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, int id, const _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationProducerRP), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, "wsnt:TopicExpression", -1, &a->_wsnt__NotificationProducerRP::TopicExpression, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "wsnt:FixedTopicSet", -1, &a->_wsnt__NotificationProducerRP::FixedTopicSet, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", -1, &a->_wsnt__NotificationProducerRP::TopicExpressionDialect, ""))
		return soap->error;
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->_wsnt__NotificationProducerRP::wstop__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnt__NotificationProducerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnt__NotificationProducerRP(soap, tag, this, type);
}

SOAP_FMAC3 _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnt__NotificationProducerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(_wsnt__NotificationProducerRP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__wsnt__NotificationProducerRP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_wsnt__NotificationProducerRP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FixedTopicSet1 = 1;
	size_t soap_flag_wstop__TopicSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap, "wsnt:TopicExpression", &a->_wsnt__NotificationProducerRP::TopicExpression, "wsnt:TopicExpressionType"))
					continue;
			}
			if (soap_flag_FixedTopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "wsnt:FixedTopicSet", &a->_wsnt__NotificationProducerRP::FixedTopicSet, "xsd:boolean"))
				{	soap_flag_FixedTopicSet1--;
					continue;
				}
				if (soap->error == SOAP_EMPTY)
				{	if (!(a->_wsnt__NotificationProducerRP::FixedTopicSet = (bool *)soap_malloc(soap, sizeof(bool))))
						return NULL;
					*a->_wsnt__NotificationProducerRP::FixedTopicSet = (bool)1;
					soap->error = SOAP_OK;
					soap_flag_FixedTopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", &a->_wsnt__NotificationProducerRP::TopicExpressionDialect, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_wstop__TopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->_wsnt__NotificationProducerRP::wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnt__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationProducerRP, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(_wsnt__NotificationProducerRP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnt__NotificationProducerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnt__NotificationProducerRP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_wsnt__NotificationProducerRP *p;
	size_t k = sizeof(_wsnt__NotificationProducerRP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__wsnt__NotificationProducerRP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _wsnt__NotificationProducerRP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _wsnt__NotificationProducerRP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _wsnt__NotificationProducerRP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _wsnt__NotificationProducerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__wsnt__NotificationProducerRP(soap, tag ? tag : "wsnt:NotificationProducerRP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnt__NotificationProducerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnt__NotificationProducerRP(soap, this, tag, type);
}

SOAP_FMAC3 _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnt__NotificationProducerRP(struct soap *soap, _wsnt__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__ResumeFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__ResumeFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__ResumeFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__ResumeFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__ResumeFailedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType), type ? type : "wsnt:ResumeFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__ResumeFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__ResumeFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, wsnt__ResumeFailedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__ResumeFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(wsnt__ResumeFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__ResumeFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__ResumeFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__ResumeFailedFaultType, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(wsnt__ResumeFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__ResumeFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__ResumeFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__ResumeFailedFaultType *p;
	size_t k = sizeof(wsnt__ResumeFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__ResumeFailedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__ResumeFailedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__ResumeFailedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__ResumeFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__ResumeFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__ResumeFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__ResumeFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__PauseFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__PauseFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__PauseFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__PauseFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__PauseFailedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__PauseFailedFaultType), type ? type : "wsnt:PauseFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__PauseFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__PauseFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, wsnt__PauseFailedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__PauseFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(wsnt__PauseFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__PauseFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__PauseFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__PauseFailedFaultType, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(wsnt__PauseFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__PauseFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__PauseFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__PauseFailedFaultType *p;
	size_t k = sizeof(wsnt__PauseFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__PauseFailedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__PauseFailedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__PauseFailedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__PauseFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__PauseFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__PauseFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__PauseFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToDestroySubscriptionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToDestroySubscriptionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToDestroySubscriptionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType), type ? type : "wsnt:UnableToDestroySubscriptionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToDestroySubscriptionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToDestroySubscriptionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(wsnt__UnableToDestroySubscriptionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToDestroySubscriptionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(wsnt__UnableToDestroySubscriptionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToDestroySubscriptionFaultType *p;
	size_t k = sizeof(wsnt__UnableToDestroySubscriptionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToDestroySubscriptionFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToDestroySubscriptionFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToDestroySubscriptionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToDestroySubscriptionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToDestroySubscriptionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToDestroySubscriptionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnacceptableTerminationTimeFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_dateTime(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime);
	this->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime = NULL;
}

void wsnt__UnacceptableTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnacceptableTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType), type ? type : "wsnt:UnacceptableTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnacceptableTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnacceptableTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(wsnt__UnacceptableTerminationTimeFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnacceptableTerminationTimeFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->wsnt__UnacceptableTerminationTimeFaultType::MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->wsnt__UnacceptableTerminationTimeFaultType::MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(wsnt__UnacceptableTerminationTimeFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnacceptableTerminationTimeFaultType *p;
	size_t k = sizeof(wsnt__UnacceptableTerminationTimeFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnacceptableTerminationTimeFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnacceptableTerminationTimeFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnacceptableTerminationTimeFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnacceptableTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnacceptableTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnacceptableTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToCreatePullPointFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToCreatePullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToCreatePullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType), type ? type : "wsnt:UnableToCreatePullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToCreatePullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToCreatePullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(wsnt__UnableToCreatePullPointFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToCreatePullPointFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(wsnt__UnableToCreatePullPointFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnableToCreatePullPointFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToCreatePullPointFaultType *p;
	size_t k = sizeof(wsnt__UnableToCreatePullPointFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToCreatePullPointFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToCreatePullPointFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToCreatePullPointFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToCreatePullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToCreatePullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToCreatePullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToDestroyPullPointFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToDestroyPullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToDestroyPullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType), type ? type : "wsnt:UnableToDestroyPullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToDestroyPullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToDestroyPullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(wsnt__UnableToDestroyPullPointFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToDestroyPullPointFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(wsnt__UnableToDestroyPullPointFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToDestroyPullPointFaultType *p;
	size_t k = sizeof(wsnt__UnableToDestroyPullPointFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToDestroyPullPointFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToDestroyPullPointFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToDestroyPullPointFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToDestroyPullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToDestroyPullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToDestroyPullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnableToGetMessagesFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__UnableToGetMessagesFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnableToGetMessagesFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType), type ? type : "wsnt:UnableToGetMessagesFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnableToGetMessagesFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnableToGetMessagesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(wsnt__UnableToGetMessagesFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnableToGetMessagesFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnableToGetMessagesFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(wsnt__UnableToGetMessagesFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnableToGetMessagesFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnableToGetMessagesFaultType *p;
	size_t k = sizeof(wsnt__UnableToGetMessagesFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnableToGetMessagesFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnableToGetMessagesFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnableToGetMessagesFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnableToGetMessagesFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnableToGetMessagesFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnableToGetMessagesFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__NoCurrentMessageOnTopicFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__NoCurrentMessageOnTopicFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__NoCurrentMessageOnTopicFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType), type ? type : "wsnt:NoCurrentMessageOnTopicFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NoCurrentMessageOnTopicFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(wsnt__NoCurrentMessageOnTopicFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NoCurrentMessageOnTopicFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(wsnt__NoCurrentMessageOnTopicFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NoCurrentMessageOnTopicFaultType *p;
	size_t k = sizeof(wsnt__NoCurrentMessageOnTopicFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NoCurrentMessageOnTopicFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NoCurrentMessageOnTopicFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NoCurrentMessageOnTopicFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NoCurrentMessageOnTopicFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NoCurrentMessageOnTopicFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NoCurrentMessageOnTopicFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_dateTime(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime);
	this->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime = NULL;
}

void wsnt__UnacceptableInitialTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnacceptableInitialTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType), type ? type : "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnacceptableInitialTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnacceptableInitialTerminationTimeFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->wsnt__UnacceptableInitialTerminationTimeFaultType::MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnacceptableInitialTerminationTimeFaultType *p;
	size_t k = sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnacceptableInitialTerminationTimeFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnacceptableInitialTerminationTimeFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnacceptableInitialTerminationTimeFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnacceptableInitialTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnacceptableInitialTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__NotifyMessageNotSupportedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__NotifyMessageNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__NotifyMessageNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType), type ? type : "wsnt:NotifyMessageNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NotifyMessageNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NotifyMessageNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(wsnt__NotifyMessageNotSupportedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NotifyMessageNotSupportedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(wsnt__NotifyMessageNotSupportedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NotifyMessageNotSupportedFaultType *p;
	size_t k = sizeof(wsnt__NotifyMessageNotSupportedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NotifyMessageNotSupportedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NotifyMessageNotSupportedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NotifyMessageNotSupportedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NotifyMessageNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NotifyMessageNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NotifyMessageNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnsupportedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
}

void wsnt__UnsupportedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnsupportedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType), type ? type : "wsnt:UnsupportedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnsupportedPolicy", -1, &a->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnsupportedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnsupportedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(wsnt__UnsupportedPolicyRequestFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnsupportedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnsupportedPolicy", &a->wsnt__UnsupportedPolicyRequestFaultType::UnsupportedPolicy, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(wsnt__UnsupportedPolicyRequestFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnsupportedPolicyRequestFaultType *p;
	size_t k = sizeof(wsnt__UnsupportedPolicyRequestFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnsupportedPolicyRequestFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnsupportedPolicyRequestFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnsupportedPolicyRequestFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnsupportedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnsupportedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnsupportedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__UnrecognizedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
}

void wsnt__UnrecognizedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__UnrecognizedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType), type ? type : "wsnt:UnrecognizedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnrecognizedPolicy", -1, &a->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__UnrecognizedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(wsnt__UnrecognizedPolicyRequestFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__UnrecognizedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnrecognizedPolicy", &a->wsnt__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(wsnt__UnrecognizedPolicyRequestFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__UnrecognizedPolicyRequestFaultType *p;
	size_t k = sizeof(wsnt__UnrecognizedPolicyRequestFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__UnrecognizedPolicyRequestFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__UnrecognizedPolicyRequestFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__UnrecognizedPolicyRequestFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__UnrecognizedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__UnrecognizedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__UnrecognizedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidMessageContentExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidMessageContentExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidMessageContentExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType), type ? type : "wsnt:InvalidMessageContentExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidMessageContentExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidMessageContentExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(wsnt__InvalidMessageContentExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidMessageContentExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(wsnt__InvalidMessageContentExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidMessageContentExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidMessageContentExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidMessageContentExpressionFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidMessageContentExpressionFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidMessageContentExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidMessageContentExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidMessageContentExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidMessageContentExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidProducerPropertiesExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidProducerPropertiesExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType), type ? type : "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidProducerPropertiesExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidProducerPropertiesExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidProducerPropertiesExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidProducerPropertiesExpressionFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidProducerPropertiesExpressionFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidProducerPropertiesExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidProducerPropertiesExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidProducerPropertiesExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__MultipleTopicsSpecifiedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__MultipleTopicsSpecifiedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__MultipleTopicsSpecifiedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType), type ? type : "wsnt:MultipleTopicsSpecifiedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__MultipleTopicsSpecifiedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(wsnt__MultipleTopicsSpecifiedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__MultipleTopicsSpecifiedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(wsnt__MultipleTopicsSpecifiedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__MultipleTopicsSpecifiedFaultType *p;
	size_t k = sizeof(wsnt__MultipleTopicsSpecifiedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__MultipleTopicsSpecifiedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__MultipleTopicsSpecifiedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__MultipleTopicsSpecifiedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__MultipleTopicsSpecifiedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__MultipleTopicsSpecifiedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__MultipleTopicsSpecifiedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicNotSupportedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__TopicNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__TopicNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType), type ? type : "wsnt:TopicNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(wsnt__TopicNotSupportedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicNotSupportedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicNotSupportedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(wsnt__TopicNotSupportedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__TopicNotSupportedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicNotSupportedFaultType *p;
	size_t k = sizeof(wsnt__TopicNotSupportedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicNotSupportedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicNotSupportedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicNotSupportedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidTopicExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__InvalidTopicExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidTopicExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType), type ? type : "wsnt:InvalidTopicExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidTopicExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidTopicExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(wsnt__InvalidTopicExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidTopicExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(wsnt__InvalidTopicExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__InvalidTopicExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidTopicExpressionFaultType *p;
	size_t k = sizeof(wsnt__InvalidTopicExpressionFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidTopicExpressionFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidTopicExpressionFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidTopicExpressionFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidTopicExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidTopicExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidTopicExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicExpressionDialectUnknownFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__TopicExpressionDialectUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__TopicExpressionDialectUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type ? type : "wsnt:TopicExpressionDialectUnknownFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicExpressionDialectUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(wsnt__TopicExpressionDialectUnknownFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicExpressionDialectUnknownFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(wsnt__TopicExpressionDialectUnknownFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicExpressionDialectUnknownFaultType *p;
	size_t k = sizeof(wsnt__TopicExpressionDialectUnknownFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicExpressionDialectUnknownFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicExpressionDialectUnknownFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicExpressionDialectUnknownFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicExpressionDialectUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicExpressionDialectUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicExpressionDialectUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__InvalidFilterFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__InvalidFilterFaultType::UnknownFilter);
}

void wsnt__InvalidFilterFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnt__InvalidFilterFaultType::UnknownFilter);
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__InvalidFilterFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__InvalidFilterFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const wsnt__InvalidFilterFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type ? type : "wsnt:InvalidFilterFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnknownFilter", -1, &a->wsnt__InvalidFilterFaultType::UnknownFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__InvalidFilterFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__InvalidFilterFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, wsnt__InvalidFilterFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__InvalidFilterFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(wsnt__InvalidFilterFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__InvalidFilterFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__InvalidFilterFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnt:UnknownFilter", &a->wsnt__InvalidFilterFaultType::UnknownFilter, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || a->wsnt__InvalidFilterFaultType::UnknownFilter.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(wsnt__InvalidFilterFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidFilterFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__InvalidFilterFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__InvalidFilterFaultType *p;
	size_t k = sizeof(wsnt__InvalidFilterFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__InvalidFilterFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__InvalidFilterFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__InvalidFilterFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__InvalidFilterFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__InvalidFilterFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__InvalidFilterFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__InvalidFilterFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__SubscribeCreationFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsnt__SubscribeCreationFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsnt__SubscribeCreationFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type ? type : "wsnt:SubscribeCreationFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__SubscribeCreationFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__SubscribeCreationFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(wsnt__SubscribeCreationFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__SubscribeCreationFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(wsnt__SubscribeCreationFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__SubscribeCreationFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__SubscribeCreationFailedFaultType *p;
	size_t k = sizeof(wsnt__SubscribeCreationFailedFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__SubscribeCreationFailedFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__SubscribeCreationFailedFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__SubscribeCreationFailedFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__SubscribeCreationFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__SubscribeCreationFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__SubscribeCreationFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__NotificationMessageHolderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsnt__NotificationMessageHolderType::SubscriptionReference = NULL;
	this->wsnt__NotificationMessageHolderType::Topic = NULL;
	this->wsnt__NotificationMessageHolderType::ProducerReference = NULL;
	this->wsnt__NotificationMessageHolderType::Message._wsnt__NotificationMessageHolderType_Message::soap_default(soap);
	/* transient soap skipped */
}

void wsnt__NotificationMessageHolderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsnt__NotificationMessageHolderType::SubscriptionReference);
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &this->wsnt__NotificationMessageHolderType::Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsnt__NotificationMessageHolderType::ProducerReference);
	this->wsnt__NotificationMessageHolderType::Message.soap_serialize(soap);
#endif
}

int wsnt__NotificationMessageHolderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->wsnt__NotificationMessageHolderType::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->wsnt__NotificationMessageHolderType::Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", -1, &a->wsnt__NotificationMessageHolderType::ProducerReference, ""))
		return soap->error;
	if ((a->wsnt__NotificationMessageHolderType::Message).soap_out(soap, "wsnt:Message", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__NotificationMessageHolderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__NotificationMessageHolderType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__NotificationMessageHolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__NotificationMessageHolderType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__NotificationMessageHolderType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_Topic1 = 1;
	size_t soap_flag_ProducerReference1 = 1;
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->wsnt__NotificationMessageHolderType::SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->wsnt__NotificationMessageHolderType::Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic1--;
					continue;
				}
			}
			if (soap_flag_ProducerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", &a->wsnt__NotificationMessageHolderType::ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference1--;
					continue;
				}
			}
			if (soap_flag_Message1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->wsnt__NotificationMessageHolderType::Message).soap_in(soap, "wsnt:Message", ""))
				{	soap_flag_Message1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnt__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__NotificationMessageHolderType *p;
	size_t k = sizeof(wsnt__NotificationMessageHolderType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__NotificationMessageHolderType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__NotificationMessageHolderType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__NotificationMessageHolderType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__NotificationMessageHolderType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__NotificationMessageHolderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__NotificationMessageHolderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__NotificationMessageHolderType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__SubscriptionPolicyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->wsnt__SubscriptionPolicyType::__any);
	/* transient soap skipped */
}

void wsnt__SubscriptionPolicyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wsnt__SubscriptionPolicyType::__any);
#endif
}

int wsnt__SubscriptionPolicyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsnt__SubscriptionPolicyType::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__SubscriptionPolicyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__SubscriptionPolicyType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__SubscriptionPolicyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__SubscriptionPolicyType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__SubscriptionPolicyType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsnt__SubscriptionPolicyType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscriptionPolicyType, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnt__SubscriptionPolicyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__SubscriptionPolicyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__SubscriptionPolicyType *p;
	size_t k = sizeof(wsnt__SubscriptionPolicyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__SubscriptionPolicyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__SubscriptionPolicyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__SubscriptionPolicyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__SubscriptionPolicyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__SubscriptionPolicyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__SubscriptionPolicyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__SubscriptionPolicyType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__FilterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->wsnt__FilterType::__any);
	/* transient soap skipped */
}

void wsnt__FilterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wsnt__FilterType::__any);
#endif
}

int wsnt__FilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__FilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__FilterType(struct soap *soap, const char *tag, int id, const wsnt__FilterType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__FilterType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsnt__FilterType::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__FilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__FilterType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__FilterType * SOAP_FMAC4 soap_in_wsnt__FilterType(struct soap *soap, const char *tag, wsnt__FilterType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__FilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__FilterType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__FilterType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsnt__FilterType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__FilterType, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 soap_instantiate_wsnt__FilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__FilterType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__FilterType *p;
	size_t k = sizeof(wsnt__FilterType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__FilterType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__FilterType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__FilterType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__FilterType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__FilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__FilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__FilterType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__FilterType * SOAP_FMAC4 soap_get_wsnt__FilterType(struct soap *soap, wsnt__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__TopicExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsnt__TopicExpressionType::__any = NULL;
	soap_default_xsd__anyURI(soap, &this->wsnt__TopicExpressionType::Dialect);
	this->wsnt__TopicExpressionType::__anyAttribute = NULL;
	this->wsnt__TopicExpressionType::__mixed = NULL;
	/* transient soap skipped */
}

void wsnt__TopicExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wsnt__TopicExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__TopicExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const wsnt__TopicExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wsnt__TopicExpressionType*)a)->Dialect), 1);
	if (((wsnt__TopicExpressionType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsnt__TopicExpressionType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->wsnt__TopicExpressionType::__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wsnt__TopicExpressionType::__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__TopicExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__TopicExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__TopicExpressionType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionType(struct soap *soap, const char *tag, wsnt__TopicExpressionType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__TopicExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__TopicExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__TopicExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wsnt__TopicExpressionType*)a)->Dialect))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsnt__TopicExpressionType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->wsnt__TopicExpressionType::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wsnt__TopicExpressionType::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__TopicExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__TopicExpressionType *p;
	size_t k = sizeof(wsnt__TopicExpressionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__TopicExpressionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__TopicExpressionType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__TopicExpressionType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__TopicExpressionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__TopicExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__TopicExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__TopicExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__TopicExpressionType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsnt__QueryExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsnt__QueryExpressionType::__any = NULL;
	soap_default_xsd__anyURI(soap, &this->wsnt__QueryExpressionType::Dialect);
	this->wsnt__QueryExpressionType::__mixed = NULL;
	/* transient soap skipped */
}

void wsnt__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wsnt__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnt__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, const wsnt__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((wsnt__QueryExpressionType*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__QueryExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->wsnt__QueryExpressionType::__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wsnt__QueryExpressionType::__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnt__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnt__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap *soap, const char *tag, wsnt__QueryExpressionType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnt__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(wsnt__QueryExpressionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsnt__QueryExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsnt__QueryExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((wsnt__QueryExpressionType*)a)->Dialect))
		return NULL;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->wsnt__QueryExpressionType::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wsnt__QueryExpressionType::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(wsnt__QueryExpressionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnt__QueryExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsnt__QueryExpressionType *p;
	size_t k = sizeof(wsnt__QueryExpressionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsnt__QueryExpressionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsnt__QueryExpressionType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsnt__QueryExpressionType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsnt__QueryExpressionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsnt__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsnt__QueryExpressionType(soap, tag ? tag : "wsnt:QueryExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnt__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnt__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap *soap, wsnt__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrfbf__BaseFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_dateTime(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, &this->wsrfbf__BaseFaultType::Description);
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	this->wsrfbf__BaseFaultType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void wsrfbf__BaseFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, &this->wsrfbf__BaseFaultType::Description);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
#endif
}

int wsrfbf__BaseFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrfbf__BaseFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, int id, const wsrfbf__BaseFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfbf__BaseFaultType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrfbf__BaseFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsrfbf__BaseFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_in_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, wsrfbf__BaseFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrfbf__BaseFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(wsrfbf__BaseFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrfbf__BaseFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrfbf__BaseFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Originator1 = 1;
	size_t soap_flag_ErrorCode1 = 1;
	size_t soap_flag_FaultCause1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			}
			if (soap_flag_Originator1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator1--;
					continue;
				}
			}
			if (soap_flag_ErrorCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsrfbf__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfbf__BaseFaultType, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(wsrfbf__BaseFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrfbf__BaseFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wsrfr:ResourceUnknownFaultType"))
		return soap_instantiate_wsrfr__ResourceUnknownFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsrfr:ResourceUnavailableFaultType"))
		return soap_instantiate_wsrfr__ResourceUnavailableFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:SubscribeCreationFailedFaultType"))
		return soap_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidFilterFaultType"))
		return soap_instantiate_wsnt__InvalidFilterFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicExpressionDialectUnknownFaultType"))
		return soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidTopicExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicNotSupportedFaultType"))
		return soap_instantiate_wsnt__TopicNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:MultipleTopicsSpecifiedFaultType"))
		return soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidMessageContentExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnrecognizedPolicyRequestFaultType"))
		return soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnsupportedPolicyRequestFaultType"))
		return soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NotifyMessageNotSupportedFaultType"))
		return soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		return soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NoCurrentMessageOnTopicFaultType"))
		return soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToGetMessagesFaultType"))
		return soap_instantiate_wsnt__UnableToGetMessagesFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroyPullPointFaultType"))
		return soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToCreatePullPointFaultType"))
		return soap_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableTerminationTimeFaultType"))
		return soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroySubscriptionFaultType"))
		return soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:PauseFailedFaultType"))
		return soap_instantiate_wsnt__PauseFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:ResumeFailedFaultType"))
		return soap_instantiate_wsnt__ResumeFailedFaultType(soap, n, NULL, NULL, size);
	wsrfbf__BaseFaultType *p;
	size_t k = sizeof(wsrfbf__BaseFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrfbf__BaseFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsrfbf__BaseFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsrfbf__BaseFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrfbf__BaseFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsrfbf__BaseFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrfbf__BaseFaultType(soap, tag ? tag : "wsrfbf:BaseFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrfbf__BaseFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrfbf__BaseFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_get_wsrfbf__BaseFaultType(struct soap *soap, wsrfbf__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfbf__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrfr__ResourceUnavailableFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsrfr__ResourceUnavailableFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsrfr__ResourceUnavailableFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrfr__ResourceUnavailableFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const char *tag, int id, const wsrfr__ResourceUnavailableFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType), type ? type : "wsrfr:ResourceUnavailableFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrfr__ResourceUnavailableFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsrfr__ResourceUnavailableFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_in_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const char *tag, wsrfr__ResourceUnavailableFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrfr__ResourceUnavailableFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(wsrfr__ResourceUnavailableFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrfr__ResourceUnavailableFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrfr__ResourceUnavailableFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsrfr__ResourceUnavailableFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(wsrfr__ResourceUnavailableFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrfr__ResourceUnavailableFaultType * SOAP_FMAC2 soap_instantiate_wsrfr__ResourceUnavailableFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrfr__ResourceUnavailableFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsrfr__ResourceUnavailableFaultType *p;
	size_t k = sizeof(wsrfr__ResourceUnavailableFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsrfr__ResourceUnavailableFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsrfr__ResourceUnavailableFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrfr__ResourceUnavailableFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsrfr__ResourceUnavailableFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrfr__ResourceUnavailableFaultType(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrfr__ResourceUnavailableFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrfr__ResourceUnavailableFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_get_wsrfr__ResourceUnavailableFaultType(struct soap *soap, wsrfr__ResourceUnavailableFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfr__ResourceUnavailableFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrfr__ResourceUnknownFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsrfbf__BaseFaultType::soap_default(soap);
}

void wsrfr__ResourceUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsrfbf__BaseFaultType::soap_serialize(soap);
#endif
}

int wsrfr__ResourceUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrfr__ResourceUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, const wsrfr__ResourceUnknownFaultType *a, const char *type)
{
	if (((wsrfbf__BaseFaultType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((wsrfbf__BaseFaultType*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType), type ? type : "wsrfr:ResourceUnknownFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsrfbf__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, &a->wsrfbf__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__BaseFaultType::FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrfr__ResourceUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_in_wsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, wsrfr__ResourceUnknownFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrfr__ResourceUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(wsrfr__ResourceUnknownFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrfr__ResourceUnknownFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrfr__ResourceUnknownFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((wsrfbf__BaseFaultType*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__BaseFaultType::Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", &a->wsrfbf__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsrfbf__BaseFaultType::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (wsrfr__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(wsrfr__ResourceUnknownFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrfr__ResourceUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsrfr__ResourceUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrfr__ResourceUnknownFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsrfr__ResourceUnknownFaultType *p;
	size_t k = sizeof(wsrfr__ResourceUnknownFaultType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsrfr__ResourceUnknownFaultType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsrfr__ResourceUnknownFaultType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrfr__ResourceUnknownFaultType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsrfr__ResourceUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrfr__ResourceUnknownFaultType(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrfr__ResourceUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrfr__ResourceUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_get_wsrfr__ResourceUnknownFaultType(struct soap *soap, wsrfr__ResourceUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__GetEventPropertiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::TopicNamespaceLocation);
	this->_tev__GetEventPropertiesResponse::wsnt__FixedTopicSet = (bool)1;
	this->_tev__GetEventPropertiesResponse::wstop__TopicSet = NULL;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::MessageContentFilterDialect);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::ProducerPropertiesFilterDialect);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_tev__GetEventPropertiesResponse::__any);
	/* transient soap skipped */
}

void _tev__GetEventPropertiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::TopicNamespaceLocation);
	soap_embedded(soap, &this->_tev__GetEventPropertiesResponse::wsnt__FixedTopicSet, SOAP_TYPE_bool);
	soap_serialize_PointerTowstop__TopicSetType(soap, &this->_tev__GetEventPropertiesResponse::wstop__TopicSet);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::MessageContentFilterDialect);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::ProducerPropertiesFilterDialect);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_tev__GetEventPropertiesResponse::__any);
#endif
}

int _tev__GetEventPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__GetEventPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, int id, const _tev__GetEventPropertiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventPropertiesResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:TopicNamespaceLocation");
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tev:TopicNamespaceLocation", -1, &a->_tev__GetEventPropertiesResponse::TopicNamespaceLocation, ""))
		return soap->error;
	if (soap_out_bool(soap, "wsnt:FixedTopicSet", -1, &a->_tev__GetEventPropertiesResponse::wsnt__FixedTopicSet, ""))
		return soap->error;
	if (!a->_tev__GetEventPropertiesResponse::wstop__TopicSet)
	{	if (soap_element_empty(soap, "wstop:TopicSet"))
			return soap->error;
	}
	else
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->_tev__GetEventPropertiesResponse::wstop__TopicSet, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", -1, &a->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tev:MessageContentFilterDialect", -1, &a->_tev__GetEventPropertiesResponse::MessageContentFilterDialect, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tev:ProducerPropertiesFilterDialect", -1, &a->_tev__GetEventPropertiesResponse::ProducerPropertiesFilterDialect, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tev:MessageContentSchemaLocation", -1, &a->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_tev__GetEventPropertiesResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__GetEventPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__GetEventPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_in__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, _tev__GetEventPropertiesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__GetEventPropertiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(_tev__GetEventPropertiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__GetEventPropertiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__GetEventPropertiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_wsnt__FixedTopicSet1 = 1;
	size_t soap_flag_wstop__TopicSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tev:TopicNamespaceLocation", &a->_tev__GetEventPropertiesResponse::TopicNamespaceLocation, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_wsnt__FixedTopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "wsnt:FixedTopicSet", &a->_tev__GetEventPropertiesResponse::wsnt__FixedTopicSet, "xsd:boolean"))
				{	soap_flag_wsnt__FixedTopicSet1--;
					continue;
				}
			}
			if (soap_flag_wstop__TopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->_tev__GetEventPropertiesResponse::wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "wsnt:TopicExpressionDialect", &a->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tev:MessageContentFilterDialect", &a->_tev__GetEventPropertiesResponse::MessageContentFilterDialect, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tev:ProducerPropertiesFilterDialect", &a->_tev__GetEventPropertiesResponse::ProducerPropertiesFilterDialect, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tev:MessageContentSchemaLocation", &a->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_tev__GetEventPropertiesResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "tev:TopicNamespaceLocation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tev__GetEventPropertiesResponse::TopicNamespaceLocation.size() < 1 || soap_flag_wsnt__FixedTopicSet1 > 0 || !a->_tev__GetEventPropertiesResponse::wstop__TopicSet || a->_tev__GetEventPropertiesResponse::wsnt__TopicExpressionDialect.size() < 1 || a->_tev__GetEventPropertiesResponse::MessageContentFilterDialect.size() < 1 || a->_tev__GetEventPropertiesResponse::MessageContentSchemaLocation.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__GetEventPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventPropertiesResponse, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(_tev__GetEventPropertiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__GetEventPropertiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetEventPropertiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__GetEventPropertiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__GetEventPropertiesResponse *p;
	size_t k = sizeof(_tev__GetEventPropertiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__GetEventPropertiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__GetEventPropertiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__GetEventPropertiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__GetEventPropertiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__GetEventPropertiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__GetEventPropertiesResponse(soap, tag ? tag : "tev:GetEventPropertiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__GetEventPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__GetEventPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_get__tev__GetEventPropertiesResponse(struct soap *soap, _tev__GetEventPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__GetEventProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tev__GetEventProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__GetEventProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__GetEventProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventProperties(struct soap *soap, const char *tag, int id, const _tev__GetEventProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventProperties), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__GetEventProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__GetEventProperties(soap, tag, this, type);
}

SOAP_FMAC3 _tev__GetEventProperties * SOAP_FMAC4 soap_in__tev__GetEventProperties(struct soap *soap, const char *tag, _tev__GetEventProperties *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__GetEventProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventProperties, sizeof(_tev__GetEventProperties), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__GetEventProperties)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__GetEventProperties *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__GetEventProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventProperties, SOAP_TYPE__tev__GetEventProperties, sizeof(_tev__GetEventProperties), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__GetEventProperties * SOAP_FMAC2 soap_instantiate__tev__GetEventProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__GetEventProperties(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__GetEventProperties *p;
	size_t k = sizeof(_tev__GetEventProperties);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__GetEventProperties, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__GetEventProperties);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__GetEventProperties, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__GetEventProperties location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__GetEventProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__GetEventProperties(soap, tag ? tag : "tev:GetEventProperties", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__GetEventProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__GetEventProperties(soap, this, tag, type);
}

SOAP_FMAC3 _tev__GetEventProperties * SOAP_FMAC4 soap_get__tev__GetEventProperties(struct soap *soap, _tev__GetEventProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__SetSynchronizationPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tev__SetSynchronizationPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__SetSynchronizationPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__SetSynchronizationPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const _tev__SetSynchronizationPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__SetSynchronizationPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__SetSynchronizationPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, _tev__SetSynchronizationPointResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__SetSynchronizationPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(_tev__SetSynchronizationPointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__SetSynchronizationPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__SetSynchronizationPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPointResponse, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(_tev__SetSynchronizationPointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__SetSynchronizationPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__SetSynchronizationPointResponse *p;
	size_t k = sizeof(_tev__SetSynchronizationPointResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__SetSynchronizationPointResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__SetSynchronizationPointResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__SetSynchronizationPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__SetSynchronizationPointResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__SetSynchronizationPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__SetSynchronizationPointResponse(soap, tag ? tag : "tev:SetSynchronizationPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__SetSynchronizationPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__SetSynchronizationPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__tev__SetSynchronizationPointResponse(struct soap *soap, _tev__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__SetSynchronizationPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tev__SetSynchronizationPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__SetSynchronizationPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__SetSynchronizationPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const _tev__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPoint), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__SetSynchronizationPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__SetSynchronizationPoint(soap, tag, this, type);
}

SOAP_FMAC3 _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_in__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, _tev__SetSynchronizationPoint *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__SetSynchronizationPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(_tev__SetSynchronizationPoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__SetSynchronizationPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__SetSynchronizationPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPoint, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(_tev__SetSynchronizationPoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__SetSynchronizationPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__SetSynchronizationPoint *p;
	size_t k = sizeof(_tev__SetSynchronizationPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__SetSynchronizationPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__SetSynchronizationPoint);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__SetSynchronizationPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__SetSynchronizationPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__SetSynchronizationPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__SetSynchronizationPoint(soap, tag ? tag : "tev:SetSynchronizationPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__SetSynchronizationPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__SetSynchronizationPoint(soap, this, tag, type);
}

SOAP_FMAC3 _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_get__tev__SetSynchronizationPoint(struct soap *soap, _tev__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__SeekResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tev__SeekResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__SeekResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__SeekResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SeekResponse(struct soap *soap, const char *tag, int id, const _tev__SeekResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SeekResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__SeekResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__SeekResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__SeekResponse * SOAP_FMAC4 soap_in__tev__SeekResponse(struct soap *soap, const char *tag, _tev__SeekResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__SeekResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SeekResponse, sizeof(_tev__SeekResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__SeekResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__SeekResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__SeekResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SeekResponse, SOAP_TYPE__tev__SeekResponse, sizeof(_tev__SeekResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__SeekResponse * SOAP_FMAC2 soap_instantiate__tev__SeekResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__SeekResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__SeekResponse *p;
	size_t k = sizeof(_tev__SeekResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__SeekResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__SeekResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__SeekResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__SeekResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__SeekResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__SeekResponse(soap, tag ? tag : "tev:SeekResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__SeekResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__SeekResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__SeekResponse * SOAP_FMAC4 soap_get__tev__SeekResponse(struct soap *soap, _tev__SeekResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__Seek::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->_tev__Seek::UtcTime);
	this->_tev__Seek::Reverse = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_tev__Seek::__any);
	/* transient soap skipped */
}

void _tev__Seek::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__Seek::UtcTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTobool(soap, &this->_tev__Seek::Reverse);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_tev__Seek::__any);
#endif
}

int _tev__Seek::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__Seek(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__Seek(struct soap *soap, const char *tag, int id, const _tev__Seek *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__Seek), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tev:UtcTime", -1, &a->_tev__Seek::UtcTime, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tev:Reverse", -1, &a->_tev__Seek::Reverse, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_tev__Seek::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__Seek::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__Seek(soap, tag, this, type);
}

SOAP_FMAC3 _tev__Seek * SOAP_FMAC4 soap_in__tev__Seek(struct soap *soap, const char *tag, _tev__Seek *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__Seek *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__Seek, sizeof(_tev__Seek), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__Seek)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__Seek *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UtcTime1 = 1;
	size_t soap_flag_Reverse1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UtcTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:UtcTime", &a->_tev__Seek::UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime1--;
					continue;
				}
			}
			if (soap_flag_Reverse1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tev:Reverse", &a->_tev__Seek::Reverse, "xsd:boolean"))
				{	soap_flag_Reverse1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_tev__Seek::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__Seek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__Seek, SOAP_TYPE__tev__Seek, sizeof(_tev__Seek), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__Seek * SOAP_FMAC2 soap_instantiate__tev__Seek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__Seek(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__Seek *p;
	size_t k = sizeof(_tev__Seek);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__Seek, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__Seek);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__Seek, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__Seek location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__Seek::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__Seek(soap, tag ? tag : "tev:Seek", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__Seek::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__Seek(soap, this, tag, type);
}

SOAP_FMAC3 _tev__Seek * SOAP_FMAC4 soap_get__tev__Seek(struct soap *soap, _tev__Seek *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__PullMessagesFaultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__duration(soap, &this->_tev__PullMessagesFaultResponse::MaxTimeout);
	soap_default_int(soap, &this->_tev__PullMessagesFaultResponse::MaxMessageLimit);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_tev__PullMessagesFaultResponse::__any);
	/* transient soap skipped */
}

void _tev__PullMessagesFaultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__PullMessagesFaultResponse::MaxMessageLimit, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_tev__PullMessagesFaultResponse::__any);
#endif
}

int _tev__PullMessagesFaultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__PullMessagesFaultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, const _tev__PullMessagesFaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesFaultResponse), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tev:MaxTimeout", -1, &a->_tev__PullMessagesFaultResponse::MaxTimeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MaxMessageLimit", -1, &a->_tev__PullMessagesFaultResponse::MaxMessageLimit, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_tev__PullMessagesFaultResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__PullMessagesFaultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__PullMessagesFaultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_in__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, _tev__PullMessagesFaultResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__PullMessagesFaultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(_tev__PullMessagesFaultResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__PullMessagesFaultResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__PullMessagesFaultResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MaxTimeout1 = 1;
	size_t soap_flag_MaxMessageLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tev:MaxTimeout", &a->_tev__PullMessagesFaultResponse::MaxTimeout, "xsd:duration"))
				{	soap_flag_MaxTimeout1--;
					continue;
				}
			}
			if (soap_flag_MaxMessageLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tev:MaxMessageLimit", &a->_tev__PullMessagesFaultResponse::MaxMessageLimit, "xsd:int"))
				{	soap_flag_MaxMessageLimit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_tev__PullMessagesFaultResponse::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxTimeout1 > 0 || soap_flag_MaxMessageLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__PullMessagesFaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesFaultResponse, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(_tev__PullMessagesFaultResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__PullMessagesFaultResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesFaultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__PullMessagesFaultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__PullMessagesFaultResponse *p;
	size_t k = sizeof(_tev__PullMessagesFaultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__PullMessagesFaultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__PullMessagesFaultResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__PullMessagesFaultResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__PullMessagesFaultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__PullMessagesFaultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__PullMessagesFaultResponse(soap, tag ? tag : "tev:PullMessagesFaultResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__PullMessagesFaultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__PullMessagesFaultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_get__tev__PullMessagesFaultResponse(struct soap *soap, _tev__PullMessagesFaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__PullMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->_tev__PullMessagesResponse::CurrentTime);
	soap_default_dateTime(soap, &this->_tev__PullMessagesResponse::TerminationTime);
	soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_tev__PullMessagesResponse::wsnt__NotificationMessage);
	/* transient soap skipped */
}

void _tev__PullMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__PullMessagesResponse::CurrentTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &this->_tev__PullMessagesResponse::TerminationTime, SOAP_TYPE_dateTime);
	soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, &this->_tev__PullMessagesResponse::wsnt__NotificationMessage);
#endif
}

int _tev__PullMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__PullMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesResponse(struct soap *soap, const char *tag, int id, const _tev__PullMessagesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:CurrentTime");
	if (soap_out_dateTime(soap, "tev:CurrentTime", -1, &a->_tev__PullMessagesResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tev:TerminationTime", -1, &a->_tev__PullMessagesResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->_tev__PullMessagesResponse::wsnt__NotificationMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__PullMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__PullMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__PullMessagesResponse * SOAP_FMAC4 soap_in__tev__PullMessagesResponse(struct soap *soap, const char *tag, _tev__PullMessagesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__PullMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(_tev__PullMessagesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__PullMessagesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__PullMessagesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CurrentTime1 = 1;
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:CurrentTime", &a->_tev__PullMessagesResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:TerminationTime", &a->_tev__PullMessagesResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->_tev__PullMessagesResponse::wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
					continue;
			}
			soap_check_result(soap, "tev:CurrentTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentTime1 > 0 || soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__PullMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesResponse, SOAP_TYPE__tev__PullMessagesResponse, sizeof(_tev__PullMessagesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__PullMessagesResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__PullMessagesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__PullMessagesResponse *p;
	size_t k = sizeof(_tev__PullMessagesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__PullMessagesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__PullMessagesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__PullMessagesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__PullMessagesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__PullMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__PullMessagesResponse(soap, tag ? tag : "tev:PullMessagesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__PullMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__PullMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__PullMessagesResponse * SOAP_FMAC4 soap_get__tev__PullMessagesResponse(struct soap *soap, _tev__PullMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__PullMessages::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__duration(soap, &this->_tev__PullMessages::Timeout);
	soap_default_int(soap, &this->_tev__PullMessages::MessageLimit);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_tev__PullMessages::__any);
	/* transient soap skipped */
}

void _tev__PullMessages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__PullMessages::MessageLimit, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_tev__PullMessages::__any);
#endif
}

int _tev__PullMessages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__PullMessages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessages(struct soap *soap, const char *tag, int id, const _tev__PullMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessages), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tev:Timeout", -1, &a->_tev__PullMessages::Timeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MessageLimit", -1, &a->_tev__PullMessages::MessageLimit, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_tev__PullMessages::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__PullMessages::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__PullMessages(soap, tag, this, type);
}

SOAP_FMAC3 _tev__PullMessages * SOAP_FMAC4 soap_in__tev__PullMessages(struct soap *soap, const char *tag, _tev__PullMessages *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__PullMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessages, sizeof(_tev__PullMessages), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__PullMessages)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__PullMessages *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Timeout1 = 1;
	size_t soap_flag_MessageLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tev:Timeout", &a->_tev__PullMessages::Timeout, "xsd:duration"))
				{	soap_flag_Timeout1--;
					continue;
				}
			}
			if (soap_flag_MessageLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tev:MessageLimit", &a->_tev__PullMessages::MessageLimit, "xsd:int"))
				{	soap_flag_MessageLimit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_tev__PullMessages::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timeout1 > 0 || soap_flag_MessageLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__PullMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessages, SOAP_TYPE__tev__PullMessages, sizeof(_tev__PullMessages), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__PullMessages * SOAP_FMAC2 soap_instantiate__tev__PullMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__PullMessages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__PullMessages *p;
	size_t k = sizeof(_tev__PullMessages);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__PullMessages, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__PullMessages);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__PullMessages, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__PullMessages location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__PullMessages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__PullMessages(soap, tag ? tag : "tev:PullMessages", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__PullMessages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__PullMessages(soap, this, tag, type);
}

SOAP_FMAC3 _tev__PullMessages * SOAP_FMAC4 soap_get__tev__PullMessages(struct soap *soap, _tev__PullMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__CreatePullPointSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference);
	soap_default_dateTime(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime);
	soap_default_dateTime(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_tev__CreatePullPointSubscriptionResponse::__any);
	/* transient soap skipped */
}

void _tev__CreatePullPointSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference);
	soap_embedded(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &this->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime, SOAP_TYPE_dateTime);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_tev__CreatePullPointSubscriptionResponse::__any);
#endif
}

int _tev__CreatePullPointSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, int id, const _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", -1, &a->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:CurrentTime", -1, &a->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_tev__CreatePullPointSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__CreatePullPointSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__CreatePullPointSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(_tev__CreatePullPointSubscriptionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__CreatePullPointSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__CreatePullPointSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_wsnt__CurrentTime1 = 1;
	size_t soap_flag_wsnt__TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", &a->_tev__CreatePullPointSubscriptionResponse::SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_wsnt__CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:CurrentTime", &a->_tev__CreatePullPointSubscriptionResponse::wsnt__CurrentTime, "xsd:dateTime"))
				{	soap_flag_wsnt__CurrentTime1--;
					continue;
				}
			}
			if (soap_flag_wsnt__TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->_tev__CreatePullPointSubscriptionResponse::wsnt__TerminationTime, "xsd:dateTime"))
				{	soap_flag_wsnt__TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_tev__CreatePullPointSubscriptionResponse::__any, ""))
					continue;
			}
			soap_check_result(soap, "tev:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference1 > 0 || soap_flag_wsnt__CurrentTime1 > 0 || soap_flag_wsnt__TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__CreatePullPointSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(_tev__CreatePullPointSubscriptionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__CreatePullPointSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__CreatePullPointSubscriptionResponse *p;
	size_t k = sizeof(_tev__CreatePullPointSubscriptionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__CreatePullPointSubscriptionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__CreatePullPointSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__CreatePullPointSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__CreatePullPointSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag ? tag : "tev:CreatePullPointSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__CreatePullPointSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__CreatePullPointSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscriptionResponse(struct soap *soap, _tev__CreatePullPointSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__CreatePullPointSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tev__CreatePullPointSubscription::Filter = NULL;
	this->_tev__CreatePullPointSubscription::InitialTerminationTime = NULL;
	this->_tev__CreatePullPointSubscription::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->_tev__CreatePullPointSubscription::__any);
	/* transient soap skipped */
}

void _tev__CreatePullPointSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &this->_tev__CreatePullPointSubscription::Filter);
	soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, &this->_tev__CreatePullPointSubscription::InitialTerminationTime);
	soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, &this->_tev__CreatePullPointSubscription::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_tev__CreatePullPointSubscription::__any);
#endif
}

int _tev__CreatePullPointSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__CreatePullPointSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, const _tev__CreatePullPointSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:Filter", -1, &a->_tev__CreatePullPointSubscription::Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", -1, &a->_tev__CreatePullPointSubscription::InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", -1, &a->_tev__CreatePullPointSubscription::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_tev__CreatePullPointSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__CreatePullPointSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__CreatePullPointSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, _tev__CreatePullPointSubscription *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__CreatePullPointSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(_tev__CreatePullPointSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__CreatePullPointSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__CreatePullPointSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_InitialTerminationTime1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tev:Filter", &a->_tev__CreatePullPointSubscription::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", &a->_tev__CreatePullPointSubscription::InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", &a->_tev__CreatePullPointSubscription::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_tev__CreatePullPointSubscription::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__CreatePullPointSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(_tev__CreatePullPointSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__CreatePullPointSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__CreatePullPointSubscription *p;
	size_t k = sizeof(_tev__CreatePullPointSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__CreatePullPointSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__CreatePullPointSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__CreatePullPointSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__CreatePullPointSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__CreatePullPointSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__CreatePullPointSubscription(soap, tag ? tag : "tev:CreatePullPointSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__CreatePullPointSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__CreatePullPointSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription(struct soap *soap, _tev__CreatePullPointSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__GetServiceCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tev__GetServiceCapabilitiesResponse::Capabilities = NULL;
	/* transient soap skipped */
}

void _tev__GetServiceCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotev__Capabilities(soap, &this->_tev__GetServiceCapabilitiesResponse::Capabilities);
#endif
}

int _tev__GetServiceCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__GetServiceCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tev:Capabilities");
	if (!a->_tev__GetServiceCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tev:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotev__Capabilities(soap, "tev:Capabilities", -1, &a->_tev__GetServiceCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__GetServiceCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(_tev__GetServiceCapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__GetServiceCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__GetServiceCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotev__Capabilities(soap, "tev:Capabilities", &a->_tev__GetServiceCapabilitiesResponse::Capabilities, "tev:Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tev:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tev__GetServiceCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tev__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(_tev__GetServiceCapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__GetServiceCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__GetServiceCapabilitiesResponse *p;
	size_t k = sizeof(_tev__GetServiceCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__GetServiceCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__GetServiceCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__GetServiceCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__GetServiceCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__GetServiceCapabilitiesResponse(soap, tag ? tag : "tev:GetServiceCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__GetServiceCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__GetServiceCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tev__GetServiceCapabilitiesResponse(struct soap *soap, _tev__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tev__GetServiceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tev__GetServiceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tev__GetServiceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tev__GetServiceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const _tev__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tev__GetServiceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tev__GetServiceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tev__GetServiceCapabilities * SOAP_FMAC4 soap_in__tev__GetServiceCapabilities(struct soap *soap, const char *tag, _tev__GetServiceCapabilities *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tev__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(_tev__GetServiceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tev__GetServiceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tev__GetServiceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tev__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilities, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(_tev__GetServiceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tev__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tev__GetServiceCapabilities *p;
	size_t k = sizeof(_tev__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tev__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tev__GetServiceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tev__GetServiceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tev__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tev__GetServiceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tev__GetServiceCapabilities(soap, tag ? tag : "tev:GetServiceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tev__GetServiceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tev__GetServiceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tev__GetServiceCapabilities * SOAP_FMAC4 soap_get__tev__GetServiceCapabilities(struct soap *soap, _tev__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tev__Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->tev__Capabilities::__any);
	this->tev__Capabilities::WSSubscriptionPolicySupport = NULL;
	this->tev__Capabilities::WSPullPointSupport = NULL;
	this->tev__Capabilities::WSPausableSubscriptionManagerInterfaceSupport = NULL;
	this->tev__Capabilities::MaxNotificationProducers = NULL;
	this->tev__Capabilities::MaxPullPoints = NULL;
	this->tev__Capabilities::PersistentNotificationStorage = NULL;
	this->tev__Capabilities::__anyAttribute = NULL;
	/* transient soap skipped */
}

void tev__Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->tev__Capabilities::__any);
#endif
}

int tev__Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tev__Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__Capabilities(struct soap *soap, const char *tag, int id, const tev__Capabilities *a, const char *type)
{
	if (((tev__Capabilities*)a)->WSSubscriptionPolicySupport)
	{	soap_set_attr(soap, "WSSubscriptionPolicySupport", soap_bool2s(soap, *((tev__Capabilities*)a)->WSSubscriptionPolicySupport), 1);
	}
	if (((tev__Capabilities*)a)->WSPullPointSupport)
	{	soap_set_attr(soap, "WSPullPointSupport", soap_bool2s(soap, *((tev__Capabilities*)a)->WSPullPointSupport), 1);
	}
	if (((tev__Capabilities*)a)->WSPausableSubscriptionManagerInterfaceSupport)
	{	soap_set_attr(soap, "WSPausableSubscriptionManagerInterfaceSupport", soap_bool2s(soap, *((tev__Capabilities*)a)->WSPausableSubscriptionManagerInterfaceSupport), 1);
	}
	if (((tev__Capabilities*)a)->MaxNotificationProducers)
	{	soap_set_attr(soap, "MaxNotificationProducers", soap_int2s(soap, *((tev__Capabilities*)a)->MaxNotificationProducers), 1);
	}
	if (((tev__Capabilities*)a)->MaxPullPoints)
	{	soap_set_attr(soap, "MaxPullPoints", soap_int2s(soap, *((tev__Capabilities*)a)->MaxPullPoints), 1);
	}
	if (((tev__Capabilities*)a)->PersistentNotificationStorage)
	{	soap_set_attr(soap, "PersistentNotificationStorage", soap_bool2s(soap, *((tev__Capabilities*)a)->PersistentNotificationStorage), 1);
	}
	if (((tev__Capabilities*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tev__Capabilities*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__Capabilities), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->tev__Capabilities::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tev__Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tev__Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tev__Capabilities * SOAP_FMAC4 soap_in_tev__Capabilities(struct soap *soap, const char *tag, tev__Capabilities *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tev__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__Capabilities, sizeof(tev__Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tev__Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tev__Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "WSSubscriptionPolicySupport", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->WSSubscriptionPolicySupport = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__Capabilities*)a)->WSSubscriptionPolicySupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "WSPullPointSupport", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->WSPullPointSupport = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__Capabilities*)a)->WSPullPointSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "WSPausableSubscriptionManagerInterfaceSupport", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->WSPausableSubscriptionManagerInterfaceSupport = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__Capabilities*)a)->WSPausableSubscriptionManagerInterfaceSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxNotificationProducers", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->MaxNotificationProducers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tev__Capabilities*)a)->MaxNotificationProducers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPullPoints", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->MaxPullPoints = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tev__Capabilities*)a)->MaxPullPoints))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PersistentNotificationStorage", 5, 0);
		if (t)
		{
			if (!(((tev__Capabilities*)a)->PersistentNotificationStorage = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tev__Capabilities*)a)->PersistentNotificationStorage))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((tev__Capabilities*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->tev__Capabilities::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tev__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__Capabilities, SOAP_TYPE_tev__Capabilities, sizeof(tev__Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tev__Capabilities * SOAP_FMAC2 soap_instantiate_tev__Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tev__Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tev__Capabilities *p;
	size_t k = sizeof(tev__Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tev__Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tev__Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tev__Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tev__Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tev__Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tev__Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tev__Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tev__Capabilities * SOAP_FMAC4 soap_get_tev__Capabilities(struct soap *soap, tev__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__token, SOAP_TYPE_xsd__token, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\+?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__nonNegativeInteger, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__NCName, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__QName, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyType)
		return (xsd__anyType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anyType *p;
	size_t k = sizeof(xsd__anyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyType(soap, tag ? tag : "xsd:anyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__ResumeSubscription(struct soap *soap, struct __tev__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__ResumeSubscription = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__ResumeSubscription(struct soap *soap, const struct __tev__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__ResumeSubscription(soap, &a->wsnt__ResumeSubscription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__ResumeSubscription(struct soap *soap, const char *tag, int id, const struct __tev__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__ResumeSubscription(soap, "wsnt:ResumeSubscription", -1, &a->wsnt__ResumeSubscription, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__ResumeSubscription * SOAP_FMAC4 soap_in___tev__ResumeSubscription(struct soap *soap, const char *tag, struct __tev__ResumeSubscription *a, const char *type)
{
	size_t soap_flag_wsnt__ResumeSubscription = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__ResumeSubscription *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__ResumeSubscription, sizeof(struct __tev__ResumeSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__ResumeSubscription(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__ResumeSubscription && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__ResumeSubscription(soap, "wsnt:ResumeSubscription", &a->wsnt__ResumeSubscription, ""))
				{	soap_flag_wsnt__ResumeSubscription--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__ResumeSubscription * SOAP_FMAC2 soap_instantiate___tev__ResumeSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__ResumeSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__ResumeSubscription *p;
	size_t k = sizeof(struct __tev__ResumeSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__ResumeSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__ResumeSubscription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__ResumeSubscription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__ResumeSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__ResumeSubscription(struct soap *soap, const struct __tev__ResumeSubscription *a, const char *tag, const char *type)
{
	if (soap_out___tev__ResumeSubscription(soap, tag ? tag : "-tev:ResumeSubscription", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__ResumeSubscription * SOAP_FMAC4 soap_get___tev__ResumeSubscription(struct soap *soap, struct __tev__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__PauseSubscription(struct soap *soap, struct __tev__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__PauseSubscription = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__PauseSubscription(struct soap *soap, const struct __tev__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__PauseSubscription(soap, &a->wsnt__PauseSubscription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__PauseSubscription(struct soap *soap, const char *tag, int id, const struct __tev__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__PauseSubscription(soap, "wsnt:PauseSubscription", -1, &a->wsnt__PauseSubscription, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__PauseSubscription * SOAP_FMAC4 soap_in___tev__PauseSubscription(struct soap *soap, const char *tag, struct __tev__PauseSubscription *a, const char *type)
{
	size_t soap_flag_wsnt__PauseSubscription = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__PauseSubscription *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__PauseSubscription, sizeof(struct __tev__PauseSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__PauseSubscription(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__PauseSubscription && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__PauseSubscription(soap, "wsnt:PauseSubscription", &a->wsnt__PauseSubscription, ""))
				{	soap_flag_wsnt__PauseSubscription--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__PauseSubscription * SOAP_FMAC2 soap_instantiate___tev__PauseSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__PauseSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__PauseSubscription *p;
	size_t k = sizeof(struct __tev__PauseSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__PauseSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__PauseSubscription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__PauseSubscription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__PauseSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__PauseSubscription(struct soap *soap, const struct __tev__PauseSubscription *a, const char *tag, const char *type)
{
	if (soap_out___tev__PauseSubscription(soap, tag ? tag : "-tev:PauseSubscription", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__PauseSubscription * SOAP_FMAC4 soap_get___tev__PauseSubscription(struct soap *soap, struct __tev__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Unsubscribe__(struct soap *soap, struct __tev__Unsubscribe__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Unsubscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Unsubscribe__(struct soap *soap, const struct __tev__Unsubscribe__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Unsubscribe(soap, &a->wsnt__Unsubscribe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Unsubscribe__(struct soap *soap, const char *tag, int id, const struct __tev__Unsubscribe__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", -1, &a->wsnt__Unsubscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe__ * SOAP_FMAC4 soap_in___tev__Unsubscribe__(struct soap *soap, const char *tag, struct __tev__Unsubscribe__ *a, const char *type)
{
	size_t soap_flag_wsnt__Unsubscribe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Unsubscribe__ *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Unsubscribe__, sizeof(struct __tev__Unsubscribe__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Unsubscribe__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Unsubscribe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", &a->wsnt__Unsubscribe, ""))
				{	soap_flag_wsnt__Unsubscribe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Unsubscribe__ * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Unsubscribe__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Unsubscribe__ *p;
	size_t k = sizeof(struct __tev__Unsubscribe__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Unsubscribe__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Unsubscribe__);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Unsubscribe__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Unsubscribe__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Unsubscribe__(struct soap *soap, const struct __tev__Unsubscribe__ *a, const char *tag, const char *type)
{
	if (soap_out___tev__Unsubscribe__(soap, tag ? tag : "-tev:Unsubscribe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe__ * SOAP_FMAC4 soap_get___tev__Unsubscribe__(struct soap *soap, struct __tev__Unsubscribe__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Unsubscribe__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Renew_(struct soap *soap, struct __tev__Renew_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Renew = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Renew_(struct soap *soap, const struct __tev__Renew_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Renew(soap, &a->wsnt__Renew);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Renew_(struct soap *soap, const char *tag, int id, const struct __tev__Renew_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Renew(soap, "wsnt:Renew", -1, &a->wsnt__Renew, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Renew_ * SOAP_FMAC4 soap_in___tev__Renew_(struct soap *soap, const char *tag, struct __tev__Renew_ *a, const char *type)
{
	size_t soap_flag_wsnt__Renew = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Renew_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Renew_, sizeof(struct __tev__Renew_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Renew_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Renew && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Renew(soap, "wsnt:Renew", &a->wsnt__Renew, ""))
				{	soap_flag_wsnt__Renew--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Renew_ * SOAP_FMAC2 soap_instantiate___tev__Renew_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Renew_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Renew_ *p;
	size_t k = sizeof(struct __tev__Renew_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Renew_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Renew_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Renew_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Renew_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Renew_(struct soap *soap, const struct __tev__Renew_ *a, const char *tag, const char *type)
{
	if (soap_out___tev__Renew_(soap, tag ? tag : "-tev:Renew", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Renew_ * SOAP_FMAC4 soap_get___tev__Renew_(struct soap *soap, struct __tev__Renew_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Renew_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__CreatePullPoint(struct soap *soap, struct __tev__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__CreatePullPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__CreatePullPoint(struct soap *soap, const struct __tev__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__CreatePullPoint(soap, &a->wsnt__CreatePullPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__CreatePullPoint(struct soap *soap, const char *tag, int id, const struct __tev__CreatePullPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__CreatePullPoint(soap, "wsnt:CreatePullPoint", -1, &a->wsnt__CreatePullPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__CreatePullPoint * SOAP_FMAC4 soap_in___tev__CreatePullPoint(struct soap *soap, const char *tag, struct __tev__CreatePullPoint *a, const char *type)
{
	size_t soap_flag_wsnt__CreatePullPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__CreatePullPoint *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__CreatePullPoint, sizeof(struct __tev__CreatePullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__CreatePullPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__CreatePullPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__CreatePullPoint(soap, "wsnt:CreatePullPoint", &a->wsnt__CreatePullPoint, ""))
				{	soap_flag_wsnt__CreatePullPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__CreatePullPoint * SOAP_FMAC2 soap_instantiate___tev__CreatePullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__CreatePullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__CreatePullPoint *p;
	size_t k = sizeof(struct __tev__CreatePullPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__CreatePullPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__CreatePullPoint);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__CreatePullPoint, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__CreatePullPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__CreatePullPoint(struct soap *soap, const struct __tev__CreatePullPoint *a, const char *tag, const char *type)
{
	if (soap_out___tev__CreatePullPoint(soap, tag ? tag : "-tev:CreatePullPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__CreatePullPoint * SOAP_FMAC4 soap_get___tev__CreatePullPoint(struct soap *soap, struct __tev__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Notify_(struct soap *soap, struct __tev__Notify_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Notify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Notify_(struct soap *soap, const struct __tev__Notify_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Notify(soap, &a->wsnt__Notify);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Notify_(struct soap *soap, const char *tag, int id, const struct __tev__Notify_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Notify(soap, "wsnt:Notify", -1, &a->wsnt__Notify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Notify_ * SOAP_FMAC4 soap_in___tev__Notify_(struct soap *soap, const char *tag, struct __tev__Notify_ *a, const char *type)
{
	size_t soap_flag_wsnt__Notify = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Notify_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Notify_, sizeof(struct __tev__Notify_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Notify_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Notify && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Notify(soap, "wsnt:Notify", &a->wsnt__Notify, ""))
				{	soap_flag_wsnt__Notify--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Notify_ * SOAP_FMAC2 soap_instantiate___tev__Notify_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Notify_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Notify_ *p;
	size_t k = sizeof(struct __tev__Notify_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Notify_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Notify_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Notify_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Notify_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Notify_(struct soap *soap, const struct __tev__Notify_ *a, const char *tag, const char *type)
{
	if (soap_out___tev__Notify_(soap, tag ? tag : "-tev:Notify", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Notify_ * SOAP_FMAC4 soap_get___tev__Notify_(struct soap *soap, struct __tev__Notify_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Notify_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__DestroyPullPoint(struct soap *soap, struct __tev__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__DestroyPullPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__DestroyPullPoint(struct soap *soap, const struct __tev__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__DestroyPullPoint(soap, &a->wsnt__DestroyPullPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__DestroyPullPoint(struct soap *soap, const char *tag, int id, const struct __tev__DestroyPullPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__DestroyPullPoint(soap, "wsnt:DestroyPullPoint", -1, &a->wsnt__DestroyPullPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__DestroyPullPoint * SOAP_FMAC4 soap_in___tev__DestroyPullPoint(struct soap *soap, const char *tag, struct __tev__DestroyPullPoint *a, const char *type)
{
	size_t soap_flag_wsnt__DestroyPullPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__DestroyPullPoint *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__DestroyPullPoint, sizeof(struct __tev__DestroyPullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__DestroyPullPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__DestroyPullPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__DestroyPullPoint(soap, "wsnt:DestroyPullPoint", &a->wsnt__DestroyPullPoint, ""))
				{	soap_flag_wsnt__DestroyPullPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__DestroyPullPoint * SOAP_FMAC2 soap_instantiate___tev__DestroyPullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__DestroyPullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__DestroyPullPoint *p;
	size_t k = sizeof(struct __tev__DestroyPullPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__DestroyPullPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__DestroyPullPoint);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__DestroyPullPoint, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__DestroyPullPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__DestroyPullPoint(struct soap *soap, const struct __tev__DestroyPullPoint *a, const char *tag, const char *type)
{
	if (soap_out___tev__DestroyPullPoint(soap, tag ? tag : "-tev:DestroyPullPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__DestroyPullPoint * SOAP_FMAC4 soap_get___tev__DestroyPullPoint(struct soap *soap, struct __tev__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetMessages(struct soap *soap, struct __tev__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__GetMessages = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetMessages(struct soap *soap, const struct __tev__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__GetMessages(soap, &a->wsnt__GetMessages);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetMessages(struct soap *soap, const char *tag, int id, const struct __tev__GetMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__GetMessages(soap, "wsnt:GetMessages", -1, &a->wsnt__GetMessages, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetMessages * SOAP_FMAC4 soap_in___tev__GetMessages(struct soap *soap, const char *tag, struct __tev__GetMessages *a, const char *type)
{
	size_t soap_flag_wsnt__GetMessages = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetMessages *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetMessages, sizeof(struct __tev__GetMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetMessages(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__GetMessages && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__GetMessages(soap, "wsnt:GetMessages", &a->wsnt__GetMessages, ""))
				{	soap_flag_wsnt__GetMessages--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__GetMessages * SOAP_FMAC2 soap_instantiate___tev__GetMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__GetMessages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__GetMessages *p;
	size_t k = sizeof(struct __tev__GetMessages);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__GetMessages, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__GetMessages);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__GetMessages, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__GetMessages location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetMessages(struct soap *soap, const struct __tev__GetMessages *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetMessages(soap, tag ? tag : "-tev:GetMessages", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetMessages * SOAP_FMAC4 soap_get___tev__GetMessages(struct soap *soap, struct __tev__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Notify(struct soap *soap, struct __tev__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Notify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Notify(struct soap *soap, const struct __tev__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Notify(soap, &a->wsnt__Notify);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Notify(struct soap *soap, const char *tag, int id, const struct __tev__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Notify(soap, "wsnt:Notify", -1, &a->wsnt__Notify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Notify * SOAP_FMAC4 soap_in___tev__Notify(struct soap *soap, const char *tag, struct __tev__Notify *a, const char *type)
{
	size_t soap_flag_wsnt__Notify = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Notify *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Notify, sizeof(struct __tev__Notify), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Notify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Notify && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Notify(soap, "wsnt:Notify", &a->wsnt__Notify, ""))
				{	soap_flag_wsnt__Notify--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Notify * SOAP_FMAC2 soap_instantiate___tev__Notify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Notify(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Notify *p;
	size_t k = sizeof(struct __tev__Notify);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Notify, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Notify);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Notify, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Notify location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Notify(struct soap *soap, const struct __tev__Notify *a, const char *tag, const char *type)
{
	if (soap_out___tev__Notify(soap, tag ? tag : "-tev:Notify", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Notify * SOAP_FMAC4 soap_get___tev__Notify(struct soap *soap, struct __tev__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetCurrentMessage(struct soap *soap, struct __tev__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__GetCurrentMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetCurrentMessage(struct soap *soap, const struct __tev__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__GetCurrentMessage(soap, &a->wsnt__GetCurrentMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetCurrentMessage(struct soap *soap, const char *tag, int id, const struct __tev__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__GetCurrentMessage(soap, "wsnt:GetCurrentMessage", -1, &a->wsnt__GetCurrentMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetCurrentMessage * SOAP_FMAC4 soap_in___tev__GetCurrentMessage(struct soap *soap, const char *tag, struct __tev__GetCurrentMessage *a, const char *type)
{
	size_t soap_flag_wsnt__GetCurrentMessage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetCurrentMessage *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetCurrentMessage, sizeof(struct __tev__GetCurrentMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetCurrentMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__GetCurrentMessage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__GetCurrentMessage(soap, "wsnt:GetCurrentMessage", &a->wsnt__GetCurrentMessage, ""))
				{	soap_flag_wsnt__GetCurrentMessage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__GetCurrentMessage * SOAP_FMAC2 soap_instantiate___tev__GetCurrentMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__GetCurrentMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__GetCurrentMessage *p;
	size_t k = sizeof(struct __tev__GetCurrentMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__GetCurrentMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__GetCurrentMessage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__GetCurrentMessage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__GetCurrentMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetCurrentMessage(struct soap *soap, const struct __tev__GetCurrentMessage *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetCurrentMessage(soap, tag ? tag : "-tev:GetCurrentMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetCurrentMessage * SOAP_FMAC4 soap_get___tev__GetCurrentMessage(struct soap *soap, struct __tev__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Subscribe(struct soap *soap, struct __tev__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Subscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Subscribe(struct soap *soap, const struct __tev__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Subscribe(soap, &a->wsnt__Subscribe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Subscribe(struct soap *soap, const char *tag, int id, const struct __tev__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Subscribe(soap, "wsnt:Subscribe", -1, &a->wsnt__Subscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Subscribe * SOAP_FMAC4 soap_in___tev__Subscribe(struct soap *soap, const char *tag, struct __tev__Subscribe *a, const char *type)
{
	size_t soap_flag_wsnt__Subscribe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Subscribe *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Subscribe, sizeof(struct __tev__Subscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Subscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Subscribe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Subscribe(soap, "wsnt:Subscribe", &a->wsnt__Subscribe, ""))
				{	soap_flag_wsnt__Subscribe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Subscribe * SOAP_FMAC2 soap_instantiate___tev__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Subscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Subscribe *p;
	size_t k = sizeof(struct __tev__Subscribe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Subscribe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Subscribe);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Subscribe, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Subscribe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Subscribe(struct soap *soap, const struct __tev__Subscribe *a, const char *tag, const char *type)
{
	if (soap_out___tev__Subscribe(soap, tag ? tag : "-tev:Subscribe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Subscribe * SOAP_FMAC4 soap_get___tev__Subscribe(struct soap *soap, struct __tev__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Unsubscribe_(struct soap *soap, struct __tev__Unsubscribe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Unsubscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Unsubscribe_(struct soap *soap, const struct __tev__Unsubscribe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Unsubscribe(soap, &a->wsnt__Unsubscribe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Unsubscribe_(struct soap *soap, const char *tag, int id, const struct __tev__Unsubscribe_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", -1, &a->wsnt__Unsubscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe_ * SOAP_FMAC4 soap_in___tev__Unsubscribe_(struct soap *soap, const char *tag, struct __tev__Unsubscribe_ *a, const char *type)
{
	size_t soap_flag_wsnt__Unsubscribe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Unsubscribe_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Unsubscribe_, sizeof(struct __tev__Unsubscribe_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Unsubscribe_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Unsubscribe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", &a->wsnt__Unsubscribe, ""))
				{	soap_flag_wsnt__Unsubscribe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Unsubscribe_ * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Unsubscribe_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Unsubscribe_ *p;
	size_t k = sizeof(struct __tev__Unsubscribe_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Unsubscribe_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Unsubscribe_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Unsubscribe_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Unsubscribe_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Unsubscribe_(struct soap *soap, const struct __tev__Unsubscribe_ *a, const char *tag, const char *type)
{
	if (soap_out___tev__Unsubscribe_(soap, tag ? tag : "-tev:Unsubscribe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe_ * SOAP_FMAC4 soap_get___tev__Unsubscribe_(struct soap *soap, struct __tev__Unsubscribe_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Unsubscribe_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Renew(struct soap *soap, struct __tev__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Renew = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Renew(struct soap *soap, const struct __tev__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Renew(soap, &a->wsnt__Renew);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Renew(struct soap *soap, const char *tag, int id, const struct __tev__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Renew(soap, "wsnt:Renew", -1, &a->wsnt__Renew, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Renew * SOAP_FMAC4 soap_in___tev__Renew(struct soap *soap, const char *tag, struct __tev__Renew *a, const char *type)
{
	size_t soap_flag_wsnt__Renew = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Renew *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Renew, sizeof(struct __tev__Renew), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Renew(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Renew && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Renew(soap, "wsnt:Renew", &a->wsnt__Renew, ""))
				{	soap_flag_wsnt__Renew--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Renew * SOAP_FMAC2 soap_instantiate___tev__Renew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Renew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Renew *p;
	size_t k = sizeof(struct __tev__Renew);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Renew, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Renew);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Renew, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Renew location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Renew(struct soap *soap, const struct __tev__Renew *a, const char *tag, const char *type)
{
	if (soap_out___tev__Renew(soap, tag ? tag : "-tev:Renew", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Renew * SOAP_FMAC4 soap_get___tev__Renew(struct soap *soap, struct __tev__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetEventProperties(struct soap *soap, struct __tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__GetEventProperties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetEventProperties(struct soap *soap, const struct __tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__GetEventProperties(soap, &a->tev__GetEventProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetEventProperties(struct soap *soap, const char *tag, int id, const struct __tev__GetEventProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__GetEventProperties(soap, "tev:GetEventProperties", -1, &a->tev__GetEventProperties, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetEventProperties * SOAP_FMAC4 soap_in___tev__GetEventProperties(struct soap *soap, const char *tag, struct __tev__GetEventProperties *a, const char *type)
{
	size_t soap_flag_tev__GetEventProperties = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetEventProperties *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetEventProperties, sizeof(struct __tev__GetEventProperties), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetEventProperties(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__GetEventProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__GetEventProperties(soap, "tev:GetEventProperties", &a->tev__GetEventProperties, ""))
				{	soap_flag_tev__GetEventProperties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__GetEventProperties * SOAP_FMAC2 soap_instantiate___tev__GetEventProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__GetEventProperties(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__GetEventProperties *p;
	size_t k = sizeof(struct __tev__GetEventProperties);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__GetEventProperties, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__GetEventProperties);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__GetEventProperties, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__GetEventProperties location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetEventProperties(struct soap *soap, const struct __tev__GetEventProperties *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetEventProperties(soap, tag ? tag : "-tev:GetEventProperties", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetEventProperties * SOAP_FMAC4 soap_get___tev__GetEventProperties(struct soap *soap, struct __tev__GetEventProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__CreatePullPointSubscription(struct soap *soap, struct __tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__CreatePullPointSubscription = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__CreatePullPointSubscription(struct soap *soap, const struct __tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__CreatePullPointSubscription(soap, &a->tev__CreatePullPointSubscription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, const struct __tev__CreatePullPointSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__CreatePullPointSubscription(soap, "tev:CreatePullPointSubscription", -1, &a->tev__CreatePullPointSubscription, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__CreatePullPointSubscription * SOAP_FMAC4 soap_in___tev__CreatePullPointSubscription(struct soap *soap, const char *tag, struct __tev__CreatePullPointSubscription *a, const char *type)
{
	size_t soap_flag_tev__CreatePullPointSubscription = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__CreatePullPointSubscription *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__CreatePullPointSubscription, sizeof(struct __tev__CreatePullPointSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__CreatePullPointSubscription(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__CreatePullPointSubscription && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__CreatePullPointSubscription(soap, "tev:CreatePullPointSubscription", &a->tev__CreatePullPointSubscription, ""))
				{	soap_flag_tev__CreatePullPointSubscription--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate___tev__CreatePullPointSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__CreatePullPointSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__CreatePullPointSubscription *p;
	size_t k = sizeof(struct __tev__CreatePullPointSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__CreatePullPointSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__CreatePullPointSubscription);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__CreatePullPointSubscription, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__CreatePullPointSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__CreatePullPointSubscription(struct soap *soap, const struct __tev__CreatePullPointSubscription *a, const char *tag, const char *type)
{
	if (soap_out___tev__CreatePullPointSubscription(soap, tag ? tag : "-tev:CreatePullPointSubscription", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__CreatePullPointSubscription * SOAP_FMAC4 soap_get___tev__CreatePullPointSubscription(struct soap *soap, struct __tev__CreatePullPointSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetServiceCapabilities(struct soap *soap, struct __tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetServiceCapabilities(struct soap *soap, const struct __tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__GetServiceCapabilities(soap, &a->tev__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tev__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__GetServiceCapabilities(soap, "tev:GetServiceCapabilities", -1, &a->tev__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetServiceCapabilities * SOAP_FMAC4 soap_in___tev__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tev__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tev__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetServiceCapabilities, sizeof(struct __tev__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__GetServiceCapabilities(soap, "tev:GetServiceCapabilities", &a->tev__GetServiceCapabilities, ""))
				{	soap_flag_tev__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tev__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__GetServiceCapabilities *p;
	size_t k = sizeof(struct __tev__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__GetServiceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__GetServiceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetServiceCapabilities(struct soap *soap, const struct __tev__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetServiceCapabilities(soap, tag ? tag : "-tev:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetServiceCapabilities * SOAP_FMAC4 soap_get___tev__GetServiceCapabilities(struct soap *soap, struct __tev__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Unsubscribe(struct soap *soap, struct __tev__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Unsubscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Unsubscribe(struct soap *soap, const struct __tev__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Unsubscribe(soap, &a->wsnt__Unsubscribe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Unsubscribe(struct soap *soap, const char *tag, int id, const struct __tev__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", -1, &a->wsnt__Unsubscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe * SOAP_FMAC4 soap_in___tev__Unsubscribe(struct soap *soap, const char *tag, struct __tev__Unsubscribe *a, const char *type)
{
	size_t soap_flag_wsnt__Unsubscribe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Unsubscribe *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Unsubscribe, sizeof(struct __tev__Unsubscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Unsubscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Unsubscribe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", &a->wsnt__Unsubscribe, ""))
				{	soap_flag_wsnt__Unsubscribe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Unsubscribe * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Unsubscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Unsubscribe *p;
	size_t k = sizeof(struct __tev__Unsubscribe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Unsubscribe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Unsubscribe);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Unsubscribe, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Unsubscribe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Unsubscribe(struct soap *soap, const struct __tev__Unsubscribe *a, const char *tag, const char *type)
{
	if (soap_out___tev__Unsubscribe(soap, tag ? tag : "-tev:Unsubscribe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe * SOAP_FMAC4 soap_get___tev__Unsubscribe(struct soap *soap, struct __tev__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__SetSynchronizationPoint(struct soap *soap, struct __tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__SetSynchronizationPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__SetSynchronizationPoint(struct soap *soap, const struct __tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__SetSynchronizationPoint(soap, &a->tev__SetSynchronizationPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct __tev__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__SetSynchronizationPoint(soap, "tev:SetSynchronizationPoint", -1, &a->tev__SetSynchronizationPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__SetSynchronizationPoint * SOAP_FMAC4 soap_in___tev__SetSynchronizationPoint(struct soap *soap, const char *tag, struct __tev__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_tev__SetSynchronizationPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__SetSynchronizationPoint *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__SetSynchronizationPoint, sizeof(struct __tev__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__SetSynchronizationPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__SetSynchronizationPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__SetSynchronizationPoint(soap, "tev:SetSynchronizationPoint", &a->tev__SetSynchronizationPoint, ""))
				{	soap_flag_tev__SetSynchronizationPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___tev__SetSynchronizationPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__SetSynchronizationPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__SetSynchronizationPoint *p;
	size_t k = sizeof(struct __tev__SetSynchronizationPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__SetSynchronizationPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__SetSynchronizationPoint);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__SetSynchronizationPoint, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__SetSynchronizationPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__SetSynchronizationPoint(struct soap *soap, const struct __tev__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out___tev__SetSynchronizationPoint(soap, tag ? tag : "-tev:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__SetSynchronizationPoint * SOAP_FMAC4 soap_get___tev__SetSynchronizationPoint(struct soap *soap, struct __tev__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Seek(struct soap *soap, struct __tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__Seek = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Seek(struct soap *soap, const struct __tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__Seek(soap, &a->tev__Seek);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Seek(struct soap *soap, const char *tag, int id, const struct __tev__Seek *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__Seek(soap, "tev:Seek", -1, &a->tev__Seek, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Seek * SOAP_FMAC4 soap_in___tev__Seek(struct soap *soap, const char *tag, struct __tev__Seek *a, const char *type)
{
	size_t soap_flag_tev__Seek = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Seek *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Seek, sizeof(struct __tev__Seek), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Seek(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__Seek && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__Seek(soap, "tev:Seek", &a->tev__Seek, ""))
				{	soap_flag_tev__Seek--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__Seek * SOAP_FMAC2 soap_instantiate___tev__Seek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__Seek(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__Seek *p;
	size_t k = sizeof(struct __tev__Seek);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__Seek, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__Seek);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__Seek, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__Seek location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Seek(struct soap *soap, const struct __tev__Seek *a, const char *tag, const char *type)
{
	if (soap_out___tev__Seek(soap, tag ? tag : "-tev:Seek", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Seek * SOAP_FMAC4 soap_get___tev__Seek(struct soap *soap, struct __tev__Seek *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__PullMessages(struct soap *soap, struct __tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__PullMessages = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__PullMessages(struct soap *soap, const struct __tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__PullMessages(soap, &a->tev__PullMessages);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__PullMessages(struct soap *soap, const char *tag, int id, const struct __tev__PullMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__PullMessages(soap, "tev:PullMessages", -1, &a->tev__PullMessages, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__PullMessages * SOAP_FMAC4 soap_in___tev__PullMessages(struct soap *soap, const char *tag, struct __tev__PullMessages *a, const char *type)
{
	size_t soap_flag_tev__PullMessages = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__PullMessages *)soap_id_enter(soap, "", a, SOAP_TYPE___tev__PullMessages, sizeof(struct __tev__PullMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__PullMessages(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__PullMessages && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__PullMessages(soap, "tev:PullMessages", &a->tev__PullMessages, ""))
				{	soap_flag_tev__PullMessages--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tev__PullMessages * SOAP_FMAC2 soap_instantiate___tev__PullMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tev__PullMessages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tev__PullMessages *p;
	size_t k = sizeof(struct __tev__PullMessages);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tev__PullMessages, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tev__PullMessages);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tev__PullMessages, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tev__PullMessages location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__PullMessages(struct soap *soap, const struct __tev__PullMessages *a, const char *tag, const char *type)
{
	if (soap_out___tev__PullMessages(soap, tag ? tag : "-tev:PullMessages", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__PullMessages * SOAP_FMAC4 soap_get___tev__PullMessages(struct soap *soap, struct __tev__PullMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__InvalidFilterFault = NULL;
	a->wsnt__InvalidMessageContentExpressionFault = NULL;
	a->wsnt__InvalidProducerPropertiesExpressionFault = NULL;
	a->wsnt__InvalidTopicExpressionFault = NULL;
	a->wsnt__MultipleTopicsSpecifiedFault = NULL;
	a->wsnt__NoCurrentMessageOnTopicFault = NULL;
	a->wsnt__NotifyMessageNotSupportedFault = NULL;
	a->wsnt__PauseFailedFault = NULL;
	a->tev__PullMessagesFaultResponse = NULL;
	a->wsrfr__ResourceUnknownFault = NULL;
	a->wsnt__ResumeFailedFault = NULL;
	a->wsnt__SubscribeCreationFailedFault = NULL;
	a->wsnt__TopicExpressionDialectUnknownFault = NULL;
	a->wsnt__TopicNotSupportedFault = NULL;
	a->wsnt__UnableToCreatePullPointFault = NULL;
	a->wsnt__UnableToDestroyPullPointFault = NULL;
	a->wsnt__UnableToDestroySubscriptionFault = NULL;
	a->wsnt__UnableToGetMessagesFault = NULL;
	a->wsnt__UnacceptableInitialTerminationTimeFault = NULL;
	a->wsnt__UnacceptableTerminationTimeFault = NULL;
	a->wsnt__UnrecognizedPolicyRequestFault = NULL;
	a->wsnt__UnsupportedPolicyRequestFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__InvalidFilterFaultType(soap, &a->wsnt__InvalidFilterFault);
	soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, &a->wsnt__InvalidMessageContentExpressionFault);
	soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, &a->wsnt__InvalidProducerPropertiesExpressionFault);
	soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(soap, &a->wsnt__InvalidTopicExpressionFault);
	soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, &a->wsnt__MultipleTopicsSpecifiedFault);
	soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, &a->wsnt__NoCurrentMessageOnTopicFault);
	soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, &a->wsnt__NotifyMessageNotSupportedFault);
	soap_serialize_PointerTowsnt__PauseFailedFaultType(soap, &a->wsnt__PauseFailedFault);
	soap_serialize_PointerTo_tev__PullMessagesFaultResponse(soap, &a->tev__PullMessagesFaultResponse);
	soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(soap, &a->wsrfr__ResourceUnknownFault);
	soap_serialize_PointerTowsnt__ResumeFailedFaultType(soap, &a->wsnt__ResumeFailedFault);
	soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(soap, &a->wsnt__SubscribeCreationFailedFault);
	soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, &a->wsnt__TopicExpressionDialectUnknownFault);
	soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(soap, &a->wsnt__TopicNotSupportedFault);
	soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(soap, &a->wsnt__UnableToCreatePullPointFault);
	soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, &a->wsnt__UnableToDestroyPullPointFault);
	soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, &a->wsnt__UnableToDestroySubscriptionFault);
	soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(soap, &a->wsnt__UnableToGetMessagesFault);
	soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, &a->wsnt__UnacceptableInitialTerminationTimeFault);
	soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, &a->wsnt__UnacceptableTerminationTimeFault);
	soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, &a->wsnt__UnrecognizedPolicyRequestFault);
	soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, &a->wsnt__UnsupportedPolicyRequestFault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidFilterFaultType(soap, "wsnt:InvalidFilterFault", -1, &a->wsnt__InvalidFilterFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, "wsnt:InvalidMessageContentExpressionFault", -1, &a->wsnt__InvalidMessageContentExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, "wsnt:InvalidProducerPropertiesExpressionFault", -1, &a->wsnt__InvalidProducerPropertiesExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, "wsnt:InvalidTopicExpressionFault", -1, &a->wsnt__InvalidTopicExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, "wsnt:MultipleTopicsSpecifiedFault", -1, &a->wsnt__MultipleTopicsSpecifiedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, "wsnt:NoCurrentMessageOnTopicFault", -1, &a->wsnt__NoCurrentMessageOnTopicFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, "wsnt:NotifyMessageNotSupportedFault", -1, &a->wsnt__NotifyMessageNotSupportedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__PauseFailedFaultType(soap, "wsnt:PauseFailedFault", -1, &a->wsnt__PauseFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", -1, &a->tev__PullMessagesFaultResponse, ""))
		return soap->error;
	if (soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, "wsrfr:ResourceUnknownFault", -1, &a->wsrfr__ResourceUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__ResumeFailedFaultType(soap, "wsnt:ResumeFailedFault", -1, &a->wsnt__ResumeFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, "wsnt:SubscribeCreationFailedFault", -1, &a->wsnt__SubscribeCreationFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, "wsnt:TopicExpressionDialectUnknownFault", -1, &a->wsnt__TopicExpressionDialectUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, "wsnt:TopicNotSupportedFault", -1, &a->wsnt__TopicNotSupportedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, "wsnt:UnableToCreatePullPointFault", -1, &a->wsnt__UnableToCreatePullPointFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, "wsnt:UnableToDestroyPullPointFault", -1, &a->wsnt__UnableToDestroyPullPointFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, "wsnt:UnableToDestroySubscriptionFault", -1, &a->wsnt__UnableToDestroySubscriptionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, "wsnt:UnableToGetMessagesFault", -1, &a->wsnt__UnableToGetMessagesFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, "wsnt:UnacceptableInitialTerminationTimeFault", -1, &a->wsnt__UnacceptableInitialTerminationTimeFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, "wsnt:UnacceptableTerminationTimeFault", -1, &a->wsnt__UnacceptableTerminationTimeFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, "wsnt:UnrecognizedPolicyRequestFault", -1, &a->wsnt__UnrecognizedPolicyRequestFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, "wsnt:UnsupportedPolicyRequestFault", -1, &a->wsnt__UnsupportedPolicyRequestFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_wsnt__InvalidFilterFault = 1;
	size_t soap_flag_wsnt__InvalidMessageContentExpressionFault = 1;
	size_t soap_flag_wsnt__InvalidProducerPropertiesExpressionFault = 1;
	size_t soap_flag_wsnt__InvalidTopicExpressionFault = 1;
	size_t soap_flag_wsnt__MultipleTopicsSpecifiedFault = 1;
	size_t soap_flag_wsnt__NoCurrentMessageOnTopicFault = 1;
	size_t soap_flag_wsnt__NotifyMessageNotSupportedFault = 1;
	size_t soap_flag_wsnt__PauseFailedFault = 1;
	size_t soap_flag_tev__PullMessagesFaultResponse = 1;
	size_t soap_flag_wsrfr__ResourceUnknownFault = 1;
	size_t soap_flag_wsnt__ResumeFailedFault = 1;
	size_t soap_flag_wsnt__SubscribeCreationFailedFault = 1;
	size_t soap_flag_wsnt__TopicExpressionDialectUnknownFault = 1;
	size_t soap_flag_wsnt__TopicNotSupportedFault = 1;
	size_t soap_flag_wsnt__UnableToCreatePullPointFault = 1;
	size_t soap_flag_wsnt__UnableToDestroyPullPointFault = 1;
	size_t soap_flag_wsnt__UnableToDestroySubscriptionFault = 1;
	size_t soap_flag_wsnt__UnableToGetMessagesFault = 1;
	size_t soap_flag_wsnt__UnacceptableInitialTerminationTimeFault = 1;
	size_t soap_flag_wsnt__UnacceptableTerminationTimeFault = 1;
	size_t soap_flag_wsnt__UnrecognizedPolicyRequestFault = 1;
	size_t soap_flag_wsnt__UnsupportedPolicyRequestFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__InvalidFilterFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidFilterFaultType(soap, "wsnt:InvalidFilterFault", &a->wsnt__InvalidFilterFault, "wsnt:InvalidFilterFaultType"))
				{	soap_flag_wsnt__InvalidFilterFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidMessageContentExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, "wsnt:InvalidMessageContentExpressionFault", &a->wsnt__InvalidMessageContentExpressionFault, "wsnt:InvalidMessageContentExpressionFaultType"))
				{	soap_flag_wsnt__InvalidMessageContentExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidProducerPropertiesExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, "wsnt:InvalidProducerPropertiesExpressionFault", &a->wsnt__InvalidProducerPropertiesExpressionFault, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
				{	soap_flag_wsnt__InvalidProducerPropertiesExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidTopicExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, "wsnt:InvalidTopicExpressionFault", &a->wsnt__InvalidTopicExpressionFault, "wsnt:InvalidTopicExpressionFaultType"))
				{	soap_flag_wsnt__InvalidTopicExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__MultipleTopicsSpecifiedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, "wsnt:MultipleTopicsSpecifiedFault", &a->wsnt__MultipleTopicsSpecifiedFault, "wsnt:MultipleTopicsSpecifiedFaultType"))
				{	soap_flag_wsnt__MultipleTopicsSpecifiedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__NoCurrentMessageOnTopicFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, "wsnt:NoCurrentMessageOnTopicFault", &a->wsnt__NoCurrentMessageOnTopicFault, "wsnt:NoCurrentMessageOnTopicFaultType"))
				{	soap_flag_wsnt__NoCurrentMessageOnTopicFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__NotifyMessageNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, "wsnt:NotifyMessageNotSupportedFault", &a->wsnt__NotifyMessageNotSupportedFault, "wsnt:NotifyMessageNotSupportedFaultType"))
				{	soap_flag_wsnt__NotifyMessageNotSupportedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__PauseFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__PauseFailedFaultType(soap, "wsnt:PauseFailedFault", &a->wsnt__PauseFailedFault, "wsnt:PauseFailedFaultType"))
				{	soap_flag_wsnt__PauseFailedFault--;
					continue;
				}
			}
			if (soap_flag_tev__PullMessagesFaultResponse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", &a->tev__PullMessagesFaultResponse, ""))
				{	soap_flag_tev__PullMessagesFaultResponse--;
					continue;
				}
			}
			if (soap_flag_wsrfr__ResourceUnknownFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, "wsrfr:ResourceUnknownFault", &a->wsrfr__ResourceUnknownFault, "wsrfr:ResourceUnknownFaultType"))
				{	soap_flag_wsrfr__ResourceUnknownFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__ResumeFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__ResumeFailedFaultType(soap, "wsnt:ResumeFailedFault", &a->wsnt__ResumeFailedFault, "wsnt:ResumeFailedFaultType"))
				{	soap_flag_wsnt__ResumeFailedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__SubscribeCreationFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, "wsnt:SubscribeCreationFailedFault", &a->wsnt__SubscribeCreationFailedFault, "wsnt:SubscribeCreationFailedFaultType"))
				{	soap_flag_wsnt__SubscribeCreationFailedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__TopicExpressionDialectUnknownFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, "wsnt:TopicExpressionDialectUnknownFault", &a->wsnt__TopicExpressionDialectUnknownFault, "wsnt:TopicExpressionDialectUnknownFaultType"))
				{	soap_flag_wsnt__TopicExpressionDialectUnknownFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__TopicNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, "wsnt:TopicNotSupportedFault", &a->wsnt__TopicNotSupportedFault, "wsnt:TopicNotSupportedFaultType"))
				{	soap_flag_wsnt__TopicNotSupportedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToCreatePullPointFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, "wsnt:UnableToCreatePullPointFault", &a->wsnt__UnableToCreatePullPointFault, "wsnt:UnableToCreatePullPointFaultType"))
				{	soap_flag_wsnt__UnableToCreatePullPointFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToDestroyPullPointFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, "wsnt:UnableToDestroyPullPointFault", &a->wsnt__UnableToDestroyPullPointFault, "wsnt:UnableToDestroyPullPointFaultType"))
				{	soap_flag_wsnt__UnableToDestroyPullPointFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToDestroySubscriptionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, "wsnt:UnableToDestroySubscriptionFault", &a->wsnt__UnableToDestroySubscriptionFault, "wsnt:UnableToDestroySubscriptionFaultType"))
				{	soap_flag_wsnt__UnableToDestroySubscriptionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToGetMessagesFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, "wsnt:UnableToGetMessagesFault", &a->wsnt__UnableToGetMessagesFault, "wsnt:UnableToGetMessagesFaultType"))
				{	soap_flag_wsnt__UnableToGetMessagesFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnacceptableInitialTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, "wsnt:UnacceptableInitialTerminationTimeFault", &a->wsnt__UnacceptableInitialTerminationTimeFault, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
				{	soap_flag_wsnt__UnacceptableInitialTerminationTimeFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnacceptableTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, "wsnt:UnacceptableTerminationTimeFault", &a->wsnt__UnacceptableTerminationTimeFault, "wsnt:UnacceptableTerminationTimeFaultType"))
				{	soap_flag_wsnt__UnacceptableTerminationTimeFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnrecognizedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, "wsnt:UnrecognizedPolicyRequestFault", &a->wsnt__UnrecognizedPolicyRequestFault, "wsnt:UnrecognizedPolicyRequestFaultType"))
				{	soap_flag_wsnt__UnrecognizedPolicyRequestFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnsupportedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, "wsnt:UnsupportedPolicyRequestFault", &a->wsnt__UnsupportedPolicyRequestFault, "wsnt:UnsupportedPolicyRequestFaultType"))
				{	soap_flag_wsnt__UnsupportedPolicyRequestFault--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_chan__ChannelInstanceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct chan__ChannelInstanceType *p;
	size_t k = sizeof(struct chan__ChannelInstanceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_chan__ChannelInstanceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct chan__ChannelInstanceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct chan__ChannelInstanceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct chan__ChannelInstanceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ProblemActionType *p;
	size_t k = sizeof(struct wsa5__ProblemActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ProblemActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ProblemActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ProblemActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__RelatesToType *p;
	size_t k = sizeof(struct wsa5__RelatesToType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__RelatesToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__RelatesToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__RelatesToType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__MetadataType *p;
	size_t k = sizeof(struct wsa5__MetadataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__MetadataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__MetadataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__MetadataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ReferenceParametersType *p;
	size_t k = sizeof(struct wsa5__ReferenceParametersType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__EndpointReferenceType *p;
	size_t k = sizeof(struct wsa5__EndpointReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeSubscription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, _wsnt__ResumeSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeSubscription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__ResumeSubscription ? type : NULL);
}

SOAP_FMAC3 _wsnt__ResumeSubscription ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeSubscription(struct soap *soap, const char *tag, _wsnt__ResumeSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__ResumeSubscription **)soap_malloc(soap, sizeof(_wsnt__ResumeSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__ResumeSubscription *)soap_instantiate__wsnt__ResumeSubscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__ResumeSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(_wsnt__ResumeSubscription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeSubscription(soap, tag ? tag : "wsnt:ResumeSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__ResumeSubscription ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeSubscription(struct soap *soap, _wsnt__ResumeSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseSubscription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, _wsnt__PauseSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseSubscription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__PauseSubscription ? type : NULL);
}

SOAP_FMAC3 _wsnt__PauseSubscription ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseSubscription(struct soap *soap, const char *tag, _wsnt__PauseSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__PauseSubscription **)soap_malloc(soap, sizeof(_wsnt__PauseSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__PauseSubscription *)soap_instantiate__wsnt__PauseSubscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__PauseSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(_wsnt__PauseSubscription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseSubscription(soap, tag ? tag : "wsnt:PauseSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__PauseSubscription ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseSubscription(struct soap *soap, _wsnt__PauseSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__CreatePullPoint))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, _wsnt__CreatePullPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__CreatePullPoint, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__CreatePullPoint ? type : NULL);
}

SOAP_FMAC3 _wsnt__CreatePullPoint ** SOAP_FMAC4 soap_in_PointerTo_wsnt__CreatePullPoint(struct soap *soap, const char *tag, _wsnt__CreatePullPoint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__CreatePullPoint **)soap_malloc(soap, sizeof(_wsnt__CreatePullPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__CreatePullPoint *)soap_instantiate__wsnt__CreatePullPoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__CreatePullPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(_wsnt__CreatePullPoint), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__CreatePullPoint(soap, tag ? tag : "wsnt:CreatePullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__CreatePullPoint ** SOAP_FMAC4 soap_get_PointerTo_wsnt__CreatePullPoint(struct soap *soap, _wsnt__CreatePullPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__DestroyPullPoint))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, _wsnt__DestroyPullPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__DestroyPullPoint, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__DestroyPullPoint ? type : NULL);
}

SOAP_FMAC3 _wsnt__DestroyPullPoint ** SOAP_FMAC4 soap_in_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, const char *tag, _wsnt__DestroyPullPoint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__DestroyPullPoint **)soap_malloc(soap, sizeof(_wsnt__DestroyPullPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__DestroyPullPoint *)soap_instantiate__wsnt__DestroyPullPoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__DestroyPullPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(_wsnt__DestroyPullPoint), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__DestroyPullPoint(soap, tag ? tag : "wsnt:DestroyPullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__DestroyPullPoint ** SOAP_FMAC4 soap_get_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, _wsnt__DestroyPullPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetMessages))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetMessages(struct soap *soap, const char *tag, int id, _wsnt__GetMessages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetMessages, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__GetMessages ? type : NULL);
}

SOAP_FMAC3 _wsnt__GetMessages ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetMessages(struct soap *soap, const char *tag, _wsnt__GetMessages **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__GetMessages **)soap_malloc(soap, sizeof(_wsnt__GetMessages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__GetMessages *)soap_instantiate__wsnt__GetMessages(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__GetMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetMessages, sizeof(_wsnt__GetMessages), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__GetMessages(soap, tag ? tag : "wsnt:GetMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__GetMessages ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetMessages(struct soap *soap, _wsnt__GetMessages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Notify(struct soap *soap, _wsnt__Notify *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Notify))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Notify(struct soap *soap, const char *tag, int id, _wsnt__Notify *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Notify, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__Notify ? type : NULL);
}

SOAP_FMAC3 _wsnt__Notify ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Notify(struct soap *soap, const char *tag, _wsnt__Notify **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Notify **)soap_malloc(soap, sizeof(_wsnt__Notify *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Notify *)soap_instantiate__wsnt__Notify(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__Notify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Notify, sizeof(_wsnt__Notify), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Notify(struct soap *soap, _wsnt__Notify *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Notify(soap, tag ? tag : "wsnt:Notify", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Notify ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Notify(struct soap *soap, _wsnt__Notify **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetCurrentMessage))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, _wsnt__GetCurrentMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetCurrentMessage, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__GetCurrentMessage ? type : NULL);
}

SOAP_FMAC3 _wsnt__GetCurrentMessage ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, const char *tag, _wsnt__GetCurrentMessage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__GetCurrentMessage **)soap_malloc(soap, sizeof(_wsnt__GetCurrentMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__GetCurrentMessage *)soap_instantiate__wsnt__GetCurrentMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__GetCurrentMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(_wsnt__GetCurrentMessage), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__GetCurrentMessage(soap, tag ? tag : "wsnt:GetCurrentMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__GetCurrentMessage ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, _wsnt__GetCurrentMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe(struct soap *soap, const char *tag, int id, _wsnt__Subscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__Subscribe ? type : NULL);
}

SOAP_FMAC3 _wsnt__Subscribe ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe(struct soap *soap, const char *tag, _wsnt__Subscribe **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Subscribe **)soap_malloc(soap, sizeof(_wsnt__Subscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Subscribe *)soap_instantiate__wsnt__Subscribe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__Subscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe, sizeof(_wsnt__Subscribe), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe(soap, tag ? tag : "wsnt:Subscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Subscribe ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe(struct soap *soap, _wsnt__Subscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Renew(struct soap *soap, _wsnt__Renew *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Renew))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Renew(struct soap *soap, const char *tag, int id, _wsnt__Renew *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Renew, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__Renew ? type : NULL);
}

SOAP_FMAC3 _wsnt__Renew ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Renew(struct soap *soap, const char *tag, _wsnt__Renew **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Renew **)soap_malloc(soap, sizeof(_wsnt__Renew *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Renew *)soap_instantiate__wsnt__Renew(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__Renew **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Renew, sizeof(_wsnt__Renew), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Renew(struct soap *soap, _wsnt__Renew *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Renew(soap, tag ? tag : "wsnt:Renew", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Renew ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Renew(struct soap *soap, _wsnt__Renew **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetEventProperties(struct soap *soap, _tev__GetEventProperties *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetEventProperties))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetEventProperties(struct soap *soap, const char *tag, int id, _tev__GetEventProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetEventProperties, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__GetEventProperties ? type : NULL);
}

SOAP_FMAC3 _tev__GetEventProperties ** SOAP_FMAC4 soap_in_PointerTo_tev__GetEventProperties(struct soap *soap, const char *tag, _tev__GetEventProperties **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__GetEventProperties **)soap_malloc(soap, sizeof(_tev__GetEventProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__GetEventProperties *)soap_instantiate__tev__GetEventProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__GetEventProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventProperties, sizeof(_tev__GetEventProperties), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetEventProperties(struct soap *soap, _tev__GetEventProperties *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__GetEventProperties(soap, tag ? tag : "tev:GetEventProperties", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__GetEventProperties ** SOAP_FMAC4 soap_get_PointerTo_tev__GetEventProperties(struct soap *soap, _tev__GetEventProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, _tev__CreatePullPointSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, _tev__CreatePullPointSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__CreatePullPointSubscription ? type : NULL);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, const char *tag, _tev__CreatePullPointSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__CreatePullPointSubscription **)soap_malloc(soap, sizeof(_tev__CreatePullPointSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__CreatePullPointSubscription *)soap_instantiate__tev__CreatePullPointSubscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__CreatePullPointSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(_tev__CreatePullPointSubscription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, _tev__CreatePullPointSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__CreatePullPointSubscription(soap, tag ? tag : "tev:CreatePullPointSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, _tev__CreatePullPointSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetServiceCapabilities(struct soap *soap, _tev__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _tev__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__GetServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 _tev__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tev__GetServiceCapabilities(struct soap *soap, const char *tag, _tev__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__GetServiceCapabilities **)soap_malloc(soap, sizeof(_tev__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__GetServiceCapabilities *)soap_instantiate__tev__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(_tev__GetServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetServiceCapabilities(struct soap *soap, _tev__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__GetServiceCapabilities(soap, tag ? tag : "tev:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tev__GetServiceCapabilities(struct soap *soap, _tev__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Unsubscribe))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, _wsnt__Unsubscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Unsubscribe, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__Unsubscribe ? type : NULL);
}

SOAP_FMAC3 _wsnt__Unsubscribe ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Unsubscribe(struct soap *soap, const char *tag, _wsnt__Unsubscribe **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Unsubscribe **)soap_malloc(soap, sizeof(_wsnt__Unsubscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Unsubscribe *)soap_instantiate__wsnt__Unsubscribe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__Unsubscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(_wsnt__Unsubscribe), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, tag ? tag : "wsnt:Unsubscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Unsubscribe ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Unsubscribe(struct soap *soap, _wsnt__Unsubscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, _tev__SetSynchronizationPoint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__SetSynchronizationPoint))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, _tev__SetSynchronizationPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__SetSynchronizationPoint, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__SetSynchronizationPoint ? type : NULL);
}

SOAP_FMAC3 _tev__SetSynchronizationPoint ** SOAP_FMAC4 soap_in_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, const char *tag, _tev__SetSynchronizationPoint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__SetSynchronizationPoint **)soap_malloc(soap, sizeof(_tev__SetSynchronizationPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__SetSynchronizationPoint *)soap_instantiate__tev__SetSynchronizationPoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(_tev__SetSynchronizationPoint), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, _tev__SetSynchronizationPoint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__SetSynchronizationPoint(soap, tag ? tag : "tev:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__SetSynchronizationPoint ** SOAP_FMAC4 soap_get_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, _tev__SetSynchronizationPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__Seek(struct soap *soap, _tev__Seek *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__Seek))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__Seek(struct soap *soap, const char *tag, int id, _tev__Seek *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__Seek, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__Seek ? type : NULL);
}

SOAP_FMAC3 _tev__Seek ** SOAP_FMAC4 soap_in_PointerTo_tev__Seek(struct soap *soap, const char *tag, _tev__Seek **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__Seek **)soap_malloc(soap, sizeof(_tev__Seek *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__Seek *)soap_instantiate__tev__Seek(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__Seek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__Seek, sizeof(_tev__Seek), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__Seek(struct soap *soap, _tev__Seek *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__Seek(soap, tag ? tag : "tev:Seek", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__Seek ** SOAP_FMAC4 soap_get_PointerTo_tev__Seek(struct soap *soap, _tev__Seek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessages(struct soap *soap, _tev__PullMessages *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessages))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessages(struct soap *soap, const char *tag, int id, _tev__PullMessages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessages, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__PullMessages ? type : NULL);
}

SOAP_FMAC3 _tev__PullMessages ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessages(struct soap *soap, const char *tag, _tev__PullMessages **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__PullMessages **)soap_malloc(soap, sizeof(_tev__PullMessages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__PullMessages *)soap_instantiate__tev__PullMessages(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__PullMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessages, sizeof(_tev__PullMessages), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessages(struct soap *soap, _tev__PullMessages *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__PullMessages(soap, tag ? tag : "tev:PullMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__PullMessages ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessages(struct soap *soap, _tev__PullMessages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, wsnt__UnsupportedPolicyRequestFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnsupportedPolicyRequestFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnsupportedPolicyRequestFaultType **)soap_malloc(soap, sizeof(wsnt__UnsupportedPolicyRequestFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnsupportedPolicyRequestFaultType *)soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnsupportedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(wsnt__UnsupportedPolicyRequestFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnsupportedPolicyRequestFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnt__UnsupportedPolicyRequestFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, wsnt__UnrecognizedPolicyRequestFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnt__UnrecognizedPolicyRequestFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnrecognizedPolicyRequestFaultType **)soap_malloc(soap, sizeof(wsnt__UnrecognizedPolicyRequestFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnrecognizedPolicyRequestFaultType *)soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnrecognizedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(wsnt__UnrecognizedPolicyRequestFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnrecognizedPolicyRequestFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnt__UnrecognizedPolicyRequestFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, wsnt__UnacceptableTerminationTimeFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableTerminationTimeFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnacceptableTerminationTimeFaultType **)soap_malloc(soap, sizeof(wsnt__UnacceptableTerminationTimeFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnacceptableTerminationTimeFaultType *)soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnacceptableTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(wsnt__UnacceptableTerminationTimeFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnacceptableTerminationTimeFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableTerminationTimeFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, wsnt__UnacceptableInitialTerminationTimeFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, wsnt__UnacceptableInitialTerminationTimeFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_malloc(soap, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnt__UnacceptableInitialTerminationTimeFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnacceptableInitialTerminationTimeFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnt__UnacceptableInitialTerminationTimeFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, wsnt__UnableToGetMessagesFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnableToGetMessagesFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, wsnt__UnableToGetMessagesFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnableToGetMessagesFaultType **)soap_malloc(soap, sizeof(wsnt__UnableToGetMessagesFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnableToGetMessagesFaultType *)soap_instantiate_wsnt__UnableToGetMessagesFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnableToGetMessagesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(wsnt__UnableToGetMessagesFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnableToGetMessagesFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, wsnt__UnableToGetMessagesFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, wsnt__UnableToDestroySubscriptionFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroySubscriptionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnableToDestroySubscriptionFaultType **)soap_malloc(soap, sizeof(wsnt__UnableToDestroySubscriptionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnableToDestroySubscriptionFaultType *)soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnableToDestroySubscriptionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(wsnt__UnableToDestroySubscriptionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnableToDestroySubscriptionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnt__UnableToDestroySubscriptionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, wsnt__UnableToDestroyPullPointFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToDestroyPullPointFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnableToDestroyPullPointFaultType **)soap_malloc(soap, sizeof(wsnt__UnableToDestroyPullPointFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnableToDestroyPullPointFaultType *)soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnableToDestroyPullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(wsnt__UnableToDestroyPullPointFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnableToDestroyPullPointFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, wsnt__UnableToDestroyPullPointFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, wsnt__UnableToCreatePullPointFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, wsnt__UnableToCreatePullPointFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__UnableToCreatePullPointFaultType **)soap_malloc(soap, sizeof(wsnt__UnableToCreatePullPointFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__UnableToCreatePullPointFaultType *)soap_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__UnableToCreatePullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(wsnt__UnableToCreatePullPointFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__UnableToCreatePullPointFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, wsnt__UnableToCreatePullPointFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, wsnt__TopicNotSupportedFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__TopicNotSupportedFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__TopicNotSupportedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicNotSupportedFaultType **)soap_malloc(soap, sizeof(wsnt__TopicNotSupportedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicNotSupportedFaultType *)soap_instantiate_wsnt__TopicNotSupportedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__TopicNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(wsnt__TopicNotSupportedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicNotSupportedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, wsnt__TopicNotSupportedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, wsnt__TopicExpressionDialectUnknownFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, wsnt__TopicExpressionDialectUnknownFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicExpressionDialectUnknownFaultType **)soap_malloc(soap, sizeof(wsnt__TopicExpressionDialectUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicExpressionDialectUnknownFaultType *)soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__TopicExpressionDialectUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(wsnt__TopicExpressionDialectUnknownFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnt__TopicExpressionDialectUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, wsnt__SubscribeCreationFailedFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, wsnt__SubscribeCreationFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__SubscribeCreationFailedFaultType **)soap_malloc(soap, sizeof(wsnt__SubscribeCreationFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__SubscribeCreationFailedFaultType *)soap_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__SubscribeCreationFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(wsnt__SubscribeCreationFailedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__SubscribeCreationFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, wsnt__SubscribeCreationFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__ResumeFailedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, wsnt__ResumeFailedFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__ResumeFailedFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__ResumeFailedFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, wsnt__ResumeFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__ResumeFailedFaultType **)soap_malloc(soap, sizeof(wsnt__ResumeFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__ResumeFailedFaultType *)soap_instantiate_wsnt__ResumeFailedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__ResumeFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(wsnt__ResumeFailedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__ResumeFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, wsnt__ResumeFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, wsrfr__ResourceUnknownFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, wsrfr__ResourceUnknownFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsrfr__ResourceUnknownFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsrfr__ResourceUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, wsrfr__ResourceUnknownFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsrfr__ResourceUnknownFaultType **)soap_malloc(soap, sizeof(wsrfr__ResourceUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsrfr__ResourceUnknownFaultType *)soap_instantiate_wsrfr__ResourceUnknownFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsrfr__ResourceUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(wsrfr__ResourceUnknownFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, wsrfr__ResourceUnknownFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsrfr__ResourceUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, wsrfr__ResourceUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, _tev__PullMessagesFaultResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessagesFaultResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, _tev__PullMessagesFaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessagesFaultResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__PullMessagesFaultResponse ? type : NULL);
}

SOAP_FMAC3 _tev__PullMessagesFaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, _tev__PullMessagesFaultResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__PullMessagesFaultResponse **)soap_malloc(soap, sizeof(_tev__PullMessagesFaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__PullMessagesFaultResponse *)soap_instantiate__tev__PullMessagesFaultResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__PullMessagesFaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(_tev__PullMessagesFaultResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, _tev__PullMessagesFaultResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, tag ? tag : "tev:PullMessagesFaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__PullMessagesFaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, _tev__PullMessagesFaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__PauseFailedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, wsnt__PauseFailedFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__PauseFailedFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__PauseFailedFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__PauseFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__PauseFailedFaultType(struct soap *soap, const char *tag, wsnt__PauseFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__PauseFailedFaultType **)soap_malloc(soap, sizeof(wsnt__PauseFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__PauseFailedFaultType *)soap_instantiate_wsnt__PauseFailedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__PauseFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(wsnt__PauseFailedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__PauseFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__PauseFailedFaultType(struct soap *soap, wsnt__PauseFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, wsnt__NotifyMessageNotSupportedFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, wsnt__NotifyMessageNotSupportedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NotifyMessageNotSupportedFaultType **)soap_malloc(soap, sizeof(wsnt__NotifyMessageNotSupportedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__NotifyMessageNotSupportedFaultType *)soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__NotifyMessageNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(wsnt__NotifyMessageNotSupportedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NotifyMessageNotSupportedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnt__NotifyMessageNotSupportedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, wsnt__NoCurrentMessageOnTopicFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, wsnt__NoCurrentMessageOnTopicFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NoCurrentMessageOnTopicFaultType **)soap_malloc(soap, sizeof(wsnt__NoCurrentMessageOnTopicFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__NoCurrentMessageOnTopicFaultType *)soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__NoCurrentMessageOnTopicFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(wsnt__NoCurrentMessageOnTopicFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NoCurrentMessageOnTopicFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnt__NoCurrentMessageOnTopicFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, wsnt__MultipleTopicsSpecifiedFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, wsnt__MultipleTopicsSpecifiedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__MultipleTopicsSpecifiedFaultType **)soap_malloc(soap, sizeof(wsnt__MultipleTopicsSpecifiedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__MultipleTopicsSpecifiedFaultType *)soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__MultipleTopicsSpecifiedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(wsnt__MultipleTopicsSpecifiedFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__MultipleTopicsSpecifiedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnt__MultipleTopicsSpecifiedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, wsnt__InvalidTopicExpressionFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidTopicExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__InvalidTopicExpressionFaultType **)soap_malloc(soap, sizeof(wsnt__InvalidTopicExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__InvalidTopicExpressionFaultType *)soap_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__InvalidTopicExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(wsnt__InvalidTopicExpressionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, wsnt__InvalidTopicExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, wsnt__InvalidProducerPropertiesExpressionFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidProducerPropertiesExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_malloc(soap, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnt__InvalidProducerPropertiesExpressionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__InvalidProducerPropertiesExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnt__InvalidProducerPropertiesExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, wsnt__InvalidMessageContentExpressionFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, wsnt__InvalidMessageContentExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__InvalidMessageContentExpressionFaultType **)soap_malloc(soap, sizeof(wsnt__InvalidMessageContentExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__InvalidMessageContentExpressionFaultType *)soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__InvalidMessageContentExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(wsnt__InvalidMessageContentExpressionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnt__InvalidMessageContentExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidFilterFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, wsnt__InvalidFilterFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidFilterFaultType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__InvalidFilterFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, wsnt__InvalidFilterFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__InvalidFilterFaultType **)soap_malloc(soap, sizeof(wsnt__InvalidFilterFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__InvalidFilterFaultType *)soap_instantiate_wsnt__InvalidFilterFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__InvalidFilterFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(wsnt__InvalidFilterFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__InvalidFilterFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, wsnt__InvalidFilterFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NCName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__ConcreteTopicExpression))
		soap_serialize_wstop__ConcreteTopicExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__ConcreteTopicExpression, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__ConcreteTopicExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, wstop__TopicType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__TopicType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicType **)soap_malloc(soap, sizeof(wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicType *)soap_instantiate_wstop__TopicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__QueryExpressionType ? type : NULL);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__QueryExpressionType **)soap_malloc(soap, sizeof(wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__QueryExpressionType *)soap_instantiate_wstop__QueryExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__Documentation ? type : NULL);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__Documentation **)soap_malloc(soap, sizeof(wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__Documentation *)soap_instantiate_wstop__Documentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(_wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Subscribe_SubscriptionPolicy *)soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__SubscriptionPolicyType ? type : NULL);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnt__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__SubscriptionPolicyType *)soap_instantiate_wsnt__SubscriptionPolicyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__TopicExpressionType ? type : NULL);
}

SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, wsnt__TopicExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicExpressionType *)soap_instantiate_wsnt__TopicExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause ? type : NULL);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_FaultCause *)soap_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode ? type : NULL);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, wstop__TopicSetType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__TopicSetType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicSetType **)soap_malloc(soap, sizeof(wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicSetType *)soap_instantiate_wstop__TopicSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__NotificationMessageHolderType ? type : NULL);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnt__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__NotificationMessageHolderType *)soap_instantiate_wsnt__NotificationMessageHolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, _tev__CreatePullPointSubscription_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(_tev__CreatePullPointSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(_tev__CreatePullPointSubscription_SubscriptionPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag ? tag : "tev:CreatePullPointSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, _tev__CreatePullPointSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType))
		soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__FilterType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__FilterType(struct soap *soap, const char *tag, int id, wsnt__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__FilterType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__FilterType ? type : NULL);
}

SOAP_FMAC3 wsnt__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnt__FilterType(struct soap *soap, const char *tag, wsnt__FilterType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__FilterType **)soap_malloc(soap, sizeof(wsnt__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__FilterType *)soap_instantiate_wsnt__FilterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotev__Capabilities(struct soap *soap, tev__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tev__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotev__Capabilities(struct soap *soap, const char *tag, int id, tev__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tev__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tev__Capabilities ? type : NULL);
}

SOAP_FMAC3 tev__Capabilities ** SOAP_FMAC4 soap_in_PointerTotev__Capabilities(struct soap *soap, const char *tag, tev__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tev__Capabilities **)soap_malloc(soap, sizeof(tev__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tev__Capabilities *)soap_instantiate_tev__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tev__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tev__Capabilities, sizeof(tev__Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotev__Capabilities(struct soap *soap, tev__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tev__Capabilities ** SOAP_FMAC4 soap_get_PointerTotev__Capabilities(struct soap *soap, tev__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, std::vector<_wstop__TopicNamespaceType_Topic> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const std::vector<_wstop__TopicNamespaceType_Topic> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wstop__TopicNamespaceType_Topic> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_wstop__TopicNamespaceType_Topic));
		}
		else
		{	a->emplace_back();
		}
		_wstop__TopicNamespaceType_Topic *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wstop__TopicNamespaceType_Topic>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wstop__TopicNamespaceType_Topic> *p;
	size_t k = sizeof(std::vector<_wstop__TopicNamespaceType_Topic> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wstop__TopicNamespaceType_Topic> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wstop__TopicNamespaceType_Topic> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wstop__TopicNamespaceType_Topic>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, std::vector<wstop__TopicType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const std::vector<wstop__TopicType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowstop__TopicType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, int id, const std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowstop__TopicType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wstop__TopicType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowstop__TopicType(soap)))
			return NULL;
		a->emplace_back();
		wstop__TopicType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, sizeof(wstop__TopicType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowstop__TopicType(soap, tag, n, "wstop:TopicType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wstop__TopicType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wstop__TopicType *> *p;
	size_t k = sizeof(std::vector<wstop__TopicType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wstop__TopicType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wstop__TopicType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wstop__TopicType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__QName(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{	if (!soap_in_xsd__QName(soap, tag, n, "xsd:QName"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, std::vector<wsnt__TopicExpressionType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const std::vector<wsnt__TopicExpressionType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__TopicExpressionType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__TopicExpressionType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, std::vector<wsnt__TopicExpressionType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap)))
			return NULL;
		a->emplace_back();
		wsnt__TopicExpressionType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__TopicExpressionType(soap, tag, n, "wsnt:TopicExpressionType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__TopicExpressionType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__TopicExpressionType *> *p;
	size_t k = sizeof(std::vector<wsnt__TopicExpressionType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__TopicExpressionType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__TopicExpressionType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__TopicExpressionType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, std::vector<_wsrfbf__BaseFaultType_Description> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const std::vector<_wsrfbf__BaseFaultType_Description> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wsrfbf__BaseFaultType_Description> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_wsrfbf__BaseFaultType_Description));
		}
		else
		{	a->emplace_back();
		}
		_wsrfbf__BaseFaultType_Description *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__wsrfbf__BaseFaultType_Description, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wsrfbf__BaseFaultType_Description> *p;
	size_t k = sizeof(std::vector<_wsrfbf__BaseFaultType_Description> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wsrfbf__BaseFaultType_Description> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wsrfbf__BaseFaultType_Description> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wsrfbf__BaseFaultType_Description>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__anyURI(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyURI(soap, tag, n, "xsd:anyURI"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, std::vector<wsnt__NotificationMessageHolderType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const std::vector<wsnt__NotificationMessageHolderType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__NotificationMessageHolderType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap)))
			return NULL;
		a->emplace_back();
		wsnt__NotificationMessageHolderType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, n, "wsnt:NotificationMessageHolderType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__NotificationMessageHolderType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__NotificationMessageHolderType *> *p;
	size_t k = sizeof(std::vector<wsnt__NotificationMessageHolderType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__NotificationMessageHolderType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__NotificationMessageHolderType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__NotificationMessageHolderType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		a->emplace_back();
		char * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, n))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
